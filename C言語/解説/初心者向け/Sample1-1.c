/**
**********************************************************************
* @file		Sample1-1.c
* @brief	浅くC言語 を学ぶためのサンプル1-1(実装)
* @date		2019/06/25
* @par		Copyright
  (c) 2019-2019 Bunya
**********************************************************************
*	@par	History
*			- 2019-06-25 Bunya
*				-# 新規作成
*
**********************************************************************
*/
// 大枠：関数(プロトタイプ宣言)、暗黙の型変換、キャスト、static、const, 配列

#include <stdio.h>	// ちょっと表示させる(printfってのを使う)ので
#include <stdlib.h>	// _countof使うので

#include "Sample1-1.h" // <-これをincludeしなくても実はコンパイルは通ります。が、引数と戻り値がチェックされないのでダメです

/**
* @brief		引数のチェックしないのサンプル。が、引数を渡されても引数名がないのでどうせ利用はできない
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample11Func1()
{
	// 変数には寿命があります。規定のスコープを抜けると寿命を迎えて、変数が削除されます。
	// で、スコープは{～}の間、関数内などです。
	// C90では関数内の変数宣言は、ブロック({}のことね)の先頭のみ許されます(これを関数の先頭と勘違いしている例は多数ある)が、
	// C99ではどこでも良いです。
	// そして、そのブロックの中と外では同名でも別の変数として扱います。
	// 外のブロックから中のブロックの変数を触ることはできません。寿命の関係でね。その逆は出来るけど
	// だから変数はより狭いブロックに入れることが肝要です。
	int x = 1;
	printf("x = %d\n", x);
	{
		int x = 3; // このxは↑のxとは、この{}内において別物です。
		printf("x = %d\n", x);
		// printfを簡単に説明。文字を表示します。
		// ""内に表示書式を入れます%dはintの表示(対象はx)、\nは改行
	}

	{
		int a = 0;
		{
			int b = a + 1;	// 一個上のaに触れます。グローバル変数もまぁ触れます
			printf("b = %d\n", b);
		}
	}

	// ifはあとでね
	if (1)
	{
		int y = 2;
	}

	// forはあとでね
	for (x = 2; x < 3; x++)
	{
		int z = 0;
	}

	// ここまでは、全て変数がブロックの先頭で宣言されているのでC90でも合法です。
	// これ出来ないと勘違いしてる人結構いますが・・・

	// ここからはC99で。宣言はどこでもOKです。
	int yx = 1;
	// このzzはforを抜けると寿命がつきます
	for (int zz = 1; zz < 2; zz++)
	{
		printf("\n");
	}

	// ちなみに、変数ですがローカル変数(関数の中とかに定義される変数)は値を与えない場合、不定値となります。
	// 後で必ず代入されるのが保証されるのでなければ宣言と同時に初期化した方が無難です。
	// というかそうしないとCoverityとかの静的解析ツールで多分怒られます。
	// あ、そうだVSは2015?位から自前の静的解析ツール(ビルド->ほにゃららでコード分析を実行)を搭載してるので、
	// 個人ではそれで調べる位でいいのでは。
	// だって大抵有料ですから。その手のツールは
}

/**
* @brief		サフィックスとかプレフィックスとか。後定数の補足
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
int Sample11Func2(void)
{
	// プレフィックス
	char a = 1;		// 10進数値を表します。
	char b = 01;	// 先頭0が8進数値を表します。大昔は使ったとのことですが、今はまず使いません。
	char c = 0x1;	// 16進数値を表します。

	// サフィックス
	// 正直これを使うと変数の型を強烈に意識しないといけないので、賛否両論かと思う。
	// が、少なくともC++でautoとかいう型推論を使う場合は非常に重要になります。
	// C言語の場合だと、キャストの代わりに手軽に使う用途が多いでしょうかね。ま、ビット演算を多用するとか、
	// 凄まじく大きな値を代入する時は気を付けないといけませんが(説明がめんどいので省く。気になる人は汎整数拡張とかで調べるよろし)
	// Uとuのように大文字、小文字は気にしない
	int d = 10;
	unsigned int e = 10U;
	long f = 10L;
	unsigned long g = 10UL;
	long long h = 10LL;
	unsigned long long i = 10ULL;
	float j = 3.1f;
	// ちなみにC++(C++11以降)だと
	// auto i = 0;としたら規格上iはint型になってしまいます。
	// もしこいつをintより大きな型で扱いたい場合、LとかLLを付けてやらないといけません。
	// あと、場合によっては警告を食らうので、"警告 0"をかかげる現場ではキャストなりこれで対応するしかありません。

	// 定数補足
	// 文字定数
	char k = 'A';	// ASCIIのAを表す
	char l = '\n';	// エスケープシーケンスの改行を表す。でもOSとかアプリ依存
	// が、これは出来るだけ忘れ去って欲しいが、'A'などの型は現行規格ではchar型でなくint型である。
	// しかし、普通はchar型に入れるので、とある標準関数(文字の種類を判別するis～系)を使う以外は忘れ去って結構。
	// isalnum(渡された値がアルファベットと数値か判断する)などは引数がintなので、こいつらだけは以下のように使用する。
	// isalnum((unsigned char)変数)

	// 文字列定数
	// ""で括ったものが文字列定数
	char *m = "This is a pen.\n \tI'm hoge\n";
	printf(m);
	// エスケープシーケンスそのものを表示する際は、\を前に入れてから。
	// ファイルやフォルダのパス(\を\\で表す)なんかで頻出ですね
	char *n = "This is a pen.\\n \\tI'm hoge\n";
	printf(n);

	// ここでは戻り値として1を呼び出し元に返します
	return 1;
}

/**
* @brief		暗黙の型変換とキャストでもやっとこかなぁ
* @param[in]	a     returnで使うだけで意味はない
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
int Sample11Func3(int a)
{
	// キャストってのは型を無理やり変換してやることです。
	// 一番質が悪いのはコンパイラに警告出されたので、キャスト・・・これはやってはいけません。
	// 実質的にキャストが必要になるのは、計算時にどうしても明示しろと(業務上)強制されるかキチンと理解できていない時くらい。
	// Lv5を超えるとポインタを無理やりキャストして云々があるが、滅多に使わないので省略
	double b = (double)10;	// 10.0でaに格納される

	// でも、キャストをいきなり否定してしまうかのように次は汎整数拡張と暗黙の型変換

	// 汎整数拡張
	// 要はint以下の変数にある種の演算をしてしまうと片っ端からintに変換されてしまうということ
	// 上で面倒なのでと書いたので簡単にだけ書く。
	// charとshortは演算子がかかると無条件でint(符号付きとか関係なし)になっちゃうよってこと。これは規格で定められてるので"そんな馬鹿な"と
	// か言っても意味はない。問題になるのは説明していない以下のようなコードの時(ビット演算使ってるのでちょっとLv5超えるかなぁ)
	unsigned char u;
	unsigned char uc;
	u = 0x5a;
	uc = (~u) >> 4;
	// 何が問題なんだ?と思うだろうが、0x5a にビット反転の~がついた時点でuはint型になってるの。
	// そうすると(~u)は0xffffffa5になってるので>>4した後にunsigned charに丸め込むと0xfaと期待する0x0aとは異なるって話。

	// それと、代入時と演算時に型の優位順でもって勝手に型が変わる(ただしint以上の型。int以下は汎整数拡張が動く)のが暗黙の型変換です。
	// int < unsigned int < long < unsigned long < float < double < long double
	// こんな感じで昇格されます

	// 代入ではこんな感じ
	// 10はサフィックスがないのでint型だが、代入先がlongなので型変換された後、long型として
	// bに格納される。+=などで代入する時もそう。
	long c = 10;

	// 式の片方が型変換規則の優先度高の場合、自動的に型変換されてから計算される。
	// よってa * 10.0の時点でdouble型に変換されている。
	// これを知らない人はキャストでもって無理やり型変換するが、不要なキャストは邪魔なだけだ
	double d = c * 10.0;

	// これはダメなパターン。割り算の分母分子が両方ともlongの為、まずlongで計算する。
	// ま、切り捨てonlyならダメなパターンでもないが、切り捨てない方が普通でしょ？
	// で、代入する際、暗黙の型変換でdoubleに変換されるが 10 / 100の小数点以下が切り捨て済みなので
	// cには0.0しか入らない。
	double e = c / 100L;

	// これダメパターン2。どうせVSなら警告食らうけどね。
	// なぜダメかというと、1がintの関係でULとの優先順位からunsinged longで計算される。
	// しかーし、64bit Windowsではlongが4byteで扱われるので、+1した時点でオーバーフローする。
	// その後、long longに変換しても時すでに遅し(=0)なのである。
	//long long f = 0xFFFFFFFFUL + 1;

	// ま、こういうのは以下のように意図的に暗黙の型変換なりを利用して入りきるサイズを意識しないとねぇ。。
	// こういう時キャスト使ってもいいけど、サフィックス付けるだけでコンパイラが正しく型を認識するよ
	long x = 0x7FFFFFFF;
	unsigned long x2 = x + 1UL;
	long long y = 1;
	long long z = x + y;

	// ここでは戻り値として引数を2倍にした値を呼び出し元に返します
	return a * 2;
}

/************************** static ***************************/
// staticがあります。意味は2種類あります。

// まず一つはプログラムの終了まで寿命を持ち続ける変数を宣言する場合です。
// 関数内と関数外の両方がありますが、どちらも寿命は同じです。
// そして、ここでは主に関数内で宣言する場合です。
// これは基本使いません。マルチスレッドなんかで使うと気持ちよく死ねます。
// 早い話が関数内のみのブロックを持ちますが、寿命はグローバル変数と同じです。
/**
* @brief		関数内のstatic変数の説明用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample11Func4(void)
{
	static int a = 0;	// 0に初期化された後は関数を抜けても演算を行おうが何しようが最後の値が保持される。
	a++;
}

// 二つ目。こちらが重要です。なぜか、業務ソースでは中々お目にかかれないことが多いですが。。。
// きちんと使われることもあるけど、全体を通してみたら・・・ねｗ

// 関数外で変数にstaticを追加した場合、externしようが何しようがSample1-1.c以外からは参照できない変数になります。
// 内部リンケージって奴ですね。逆にSample1-1.c内ではどの関数からも参照できる変数として扱えます。
// "それの存在意義って何？"と思う人が居るでしょうが、C言語も高レベルになると1ヘッダと1ソース
// でクラスのように扱うようになります。(※実際は複数ファイルから構成されることもある)
// その時、このstatic変数はクラスのprivateメンバ変数のような扱いに近くなります。
// ただ、どちらにせよ寿命はグローバル変数と変わらない上、性質上状態を内包することが多いので、
// むやみやたらに使ってはいけません。
//
// また、ライブラリとしてソースファイルを分離して使う場合や、
// ある種の組み方をする場合はどうしても必要になります。C言語には、名前空間もクラスもありませんので
// ただ、classのprivate変数をclass限定のグローバル変数として扱う例は数限りなくあることをご注意下さい。
// なので、オブジェクト指向だったらグローバル変数は使わない云々という話に私は懐疑的です。classのメンバ変数を
// classのメソッドで好き勝手変更したら、それなんてグローバル変数？という話になりますので
static int a;

// 関数にstaticを追加した場合、変数と同じでSample1-1.c内以外から呼び出しが出来ません。
// このサンプルでは、main.cに公開するヘッダにプロトタイプを書いているのがアレレですが、普通は公開しないヘッダに
// 書くものです。ま、クラスで言うとprivateメソッドと等価でしょうね。
/**
* @brief		関数にstaticを使う例
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
static void Sample11Func5(void)
{
}

/************************** const ***************************/
/**
* @brief		const変数の説明用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample11Func6(void)
{
	// const 書き換え不能な何かです。以上
	// と言いたいところですが、それは理不尽すぎなので
	const int x = 10;
	printf("x = %d\n", x);
	// x = 11; 書き換え不能なのでエラーになります

	// 関数限定の定数とかファイル限定の定数、あるいは関数引数のポインタ書き換え阻止に使います。
	// ただ、関数引数のポインタ書き換え阻止は、誤解もあってどうかな？というのが個人の感想です。

	// 以下の式はC言語では使えません。C99以上かつVLAがサポートされてればいけると思いますが、
	// VSはVLAをサポートしてませんので。
	// 配列のサイズは定数式で割り当てる必要がありますが、C言語ではconst変数は定数ではないからです。
	// なので、恐らく仕事のC言語を見かけるのは、どうかなぁと書いた関数引数のポインタ書き換え阻止のみでしょう。
	// あ、文字列の配列でconstを使われることがありますが、ポインタとの絡みで変なことしてるのは多いです。
	//int array[x];
}

/************************** 配列 ***************************/
/**
* @brief		配列の説明用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample11Func7(void)
{
	// はい、では、配列を扱います。
	// 配列は同じ型の変数を1変数で複数保持することができるものです。
	// なので、複数のオブジェクトの集合体(1つ以上のオブジェクトも含む)を表す集成体型です。
	// C言語において、集成体型は配列と構造体と思っとけばいいです。書くかどうかは未定ですが、共用体型は含まれません

	// これでint型の変数が3個用意されます。でも、初期値はないので格納される各値は不定値です。
	//int a[3]; <-この変数使ってないって警告うるさいのでコメントアウト。エラーになるわけじゃない

	// ↓だとint型の変数が3個用意され、初期値は1,2,3が入ってます。
	int b[3] = { 1, 2, 3 };
	// ↓だと、最初の要素が1で初期化され、残りの2要素は0です。
	// これは集成体型で指定されない値は0初期化されるという規則に従うものです。
	// なぜか、このことを知らない"ソフトウェア エンジニア"もいらっしゃいますが
	int c[3] = { 1 };

	// ちなみに後の構造体でもそうですが、↓すると全要素が0で初期化されます。
	int cc[5] = { 0 };
	// これは先頭要素を0で初期化して、残りを0初期化するから全体が0で初期化されるという話です。
	// このようにせず、配列や構造体でmemsetというのを用いて全体を0初期化する人がちょくちょくいますが、
	// ほっとけばいいです。皆さんは↑のようにして下さい。
	// まぁ関数内で何回も初期化される配列があるならmemsetというのもなくはないですが、
	// C99以降ならforと複合リテラル＆指示付き初期化でいいじゃんと思わなくもない。多分生成される機械語同じだろうし

	// また配列で要素数を宣言せずに定義した場合、要素数はコンパイラが自動計算します。
	// ↓だとdは5要素を持つ配列として定義されます。
	// 文字列含め、出来る限りこの形を推奨します。
	int d[] = { 1, 2, 3, 4, 5 };

	// この後で使うのでsizeofの触りを。
	// sizeofを適用した型の結果は符号なしのsize_t型となります。
	// ただし、sizeof(char)は実際のビット数に関係なく1と規格で決まっています。
	// sizeofを配列に適用すると、配列の要素型サイズ*要素数と等しくなります。
	// 後で説明する構造体に適用した場合、構造体全体のサイズになります。
	// 他にも色々ありますが、まぁsizeofを実践で使うのはこんな所じゃないでしょうか

	// ちなみに、C言語では普通配列の要素数は分かりません。
	// なので #define COUNTOF(array) (sizeof(array) / sizeof(array[0]))なんてものが定義されたりします。
	// まぁ、この講座？はVS前提なので、最初から用意されている_countofを使うとします。
	// なぜ、↑のdefineで要素数が求まるかと言うと、最初のsizeofというので配列全体のサイズが返ってきます。そして、
	// sizeof(配列[0])で0番目の要素数のサイズが手に入ります。それを割ると要素数が分かるということです。
	printf("d[]の要素数 = %d\n", _countof(d));

	// ただし、配列を関数の引数で渡す場合、後で述べるポインタを使う必要があります。
	// このポインタで渡した配列の要素は求めることが出来ません。なぜならポインタというものにsizeofを適用すると
	// ポインタ型のサイズを返してくるからです。これ意外とバグになりやすいです。
	// 配列を関数で渡してそれのサイズを知りたいなら面倒でもサイズを教えてあげて下さい、引数で

	// ちなみにアクセスはこんな感じです。
	// これはd配列の最初の要素に6を入れてます。なのでdは、{6,2,3,4,5}を持つことになります。
	// 話は前後しているでしょうが、配列は0番目から値が格納されます。ま、これは皆さん分かっていることでしょうから、
	// 詳しいことは省きます
	d[0] = 6;

	// では、forで回す場合です。制御構文は後で書くのでふーん位で
	for (int i = 0; i < _countof(d); i++)
		printf("%d = %d\n", (i + 1), d[i]);

	// あ、そうそう。printfですが、さらっと書くと
	// printf("書式", 書式内で指定された変数1, 変数2・・・)です。
	// 詳しくはライブラリ編で書くかもしれない。

	// 配列最後は多次元配列です。ま、テーブル表記でお決まりのを書くとかしか普段は使わないですけどね
	int e[2][2] = { {0,1},{2,3} };
	// 表示してみましょう
	for (int i = 0; i < _countof(e); i++)
		for (int j = 0; j < countof2(e); j++)
			printf("e[%d][%d] = %d\n", i, j, e[i][j]);

	// 要素数が異なる場合は↓の感じ
	int f[3][4] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
	// が、実際は実務では多分こう書く
	//int e[][4] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
	// なぜなら、4は省略できないのでどうしようもないが、前はコンパイラが勝手にサイズを合わせてくれるから。
	// それと、実際は見やすさのため行下げ＆インデントする。
	// 後↓もOKね
	int g[][4] = { { 0,1,2,3 },{ 4, },{ 8,9, } };

	// ・・・あ。一つ注意があったわ。
	// int x[100] = {0};
	// printf("x is size(%d)\n", 100);
	// うっかりするとやりがちですが、この書き方良くありません。
	// これだと最初の100を変えることがあるとprintfがバグの元になります。_countofとか使ってくださいね
	// こんな風に書かねぇよと思うかもしれませんが、直値じゃなくdefineだったら意外とやりがちです。
}
