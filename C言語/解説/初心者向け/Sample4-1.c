/**
**********************************************************************
* @file		Sample4-1.c
* @brief	浅くC言語 を学ぶためのサンプル4-1(実装)
* @date		2021/04/13
* @par		Copyright
  (c) 2019-2021 Bunya
**********************************************************************
*	@par	History
*			- 2019-07-08 Bunya
*				-# 新規作成
*			- 2020-09-03 Bunya
*				-# ポインタ渡しについて内容を追加。
*			- 2020-09-07 Bunya
*				-# mallocのキャストについて記載を修正。
*			- 2021-04-13 Bunya
*				-# ミスや誤解を招く内容を訂正。
*
**********************************************************************
*/
// 大枠：ポインタ、関数(値渡し、ポインタ渡し)、動的確保

#include "Sample4-1.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// さて、C言語の文法はここで最後です！

/************************** ポインタ ***************************/
/**
* @brief		ポインタの説明用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample41Func1(void)
{
	// C言語を扱う以上、どうしても避けては通れないポインタの説明です。
	// ただ、ここで述べるポインタって速度とか気にしないでよければ、そんなに使う必要がないものです。
	// ポインタ使うのがかっこいいなんて人もたまにいますけど。
	// ※ポインタ演算とかいうのは余程のことがないかぎり今は早くなりません。関数の引数とかで発生するコピーコストってのだと多少
	//   差がつきますけど、そもそも発生が少ないケースでは気づかない可能性すらあります。
	// あと、ポインタ同様にC言語はアセンブラやメモリが分からないとって人いますが、そんなのかなり複雑なものを作成する
	// Lv5以上の人が必要とするものです。普通にC言語で作成したらそんなの知らなくても出来ちゃいますがな

	// 重要なポイント1：
	//    古いコードのメンテや頭固い人(何故ポインタを使わない！とか言う人)が存在したり、文法上避けようがない以外、必要なければ使うな。
	//    最適化を阻害する。し、バグが入りやすくなる。

	// 重要なポイント2：
	//    よっぽど複雑？なデータ構造(木構造とか、DBとか)を作成する(それ自体、普通はあまりないでしょう)時以外、
	//    実はシングルポインタ以上を扱うことは稀です。関数ポインタってのだとちょっと話は別ですが、あれもtypedefってお呪いに
	//    よって、表記上はシングルポインタに成り下がることが多数ですし。
	//    関数に引数で渡す場合も大体シングルポインタで扱うことが圧倒的に多いです。
	//    なので、ここではシングルポインタを理解することを主眼とします。やたらにシングルポインタより複雑なポインタが
	//    出現したら何かおかしいと感じて下さい。私自身滅多なことではシングルより複雑なポインタを扱うことはありません。

	// 重要なポイント3(でもポインタというより動的確保ですな)：
	//    勘違いしてる人もいますが、複雑なデータ構造を扱うのでない限り、めったやたらにメモリ確保とかいうのが
	//    使われることはありません。一般的な処理では必要ない(設定ファイルとか大抵最大長が決まってるでしょ？)からです。
	//    それにメモリの確保解放が頻発すると遅いですし、フラグメンテーションなんてものでメモリが使えなくなりますし。
	//    なので、GCのアピールポイントである、メモリの解放を気にしなくて良いって奴も、あまりメリットになりません。
	//    ※ 冗談ではなく10万行位のソースでメモリ確保が1つもないなんてのは現実的にあります。
	//    普通は固定配列で代用されちゃいますね。Windowsのスタックは標準で1MBとか使えるので、よほど複雑なデータとかじゃないと、
	//    スタックオーバーフローにもならないから、普通のデータ構造でメモリを確保する必要がないんです。
	//    ※あ、そういえば以前1MBじゃ足らないからって4MBに増やして、動的確保しないようにしてた人がいたなぁ。
	//      今はメモリ潤沢なのでそれもありですけど、その前にその複雑なデータをシェイプアップしたら？なんて思わなくもなかった

	//    CSVのファイルで1レコードがとんでもない長さの糞設計だとかならありえますが。。。。
	//    しかし、それも1フィールドずつ読み込めば大抵普通の配列ですんじゃいますしね
	//    あぁ、GNUのコーディング規約に固定長を前提にした配列じゃなく、可変長で扱えるようにしろってのがあった気がするなぁ。
	//    でも、そんなことしてもメリットがあることって少ないと思うけど。
	//    ・・・んー。基本的なデータ構造を扱うライブラリが用意されてない職場ならそいうので使うかもしれない。

	//    それ以外でそんなに使うかなぁ。。。
	//    生粋の組み込み(スタック量 KB単位、最大メモリ 100MB以下)なら動的確保が必要なことありますが、最近はLinuxかWindows使う組み込み
	//    ばっかりなので、メモリ量やCPU速度なんて昔に比べたら制限なんて無いに等しい・・・

	// ポインタについてまずは簡単に述べます。
	// C言語の規格から引用するね。
	// "ポインタ型は、被参照型(関数型、オブジェクト型または不完全型)の実体を参照するための値を持つオブジェクト"
	// ただし、ポインタ型というものは単独では存在しなくて、必ず何かの型から派生します。
	// なんのこっちゃいな？ですよね。まぁ↓で説明します。

	int a = 1;		// これはaという変数の宣言よね。これはintというオブジェクト型なので被参照型です。
					// ここではintの変数が確保され、その変数に1が入ります。

	int *b;			// これはbというポインタ型を宣言してます。この場合、intへのポインタを宣言したわけです。
					// で、ポインタ型は被参照型の実体を参照しなければいけませんが、ここではまだ参照先がありません。

	b = &a;			// bが参照する先としてaを割り当てます。割り当てないでアクセスするとメモリ保護違反を食らいます。
					// 割り当てないのは、そもそも規格の"実体を参照する"に反します。だから、怒られるのです。
					// 参照先を割り当てる変数の前に&を付けると、派生元の実体の参照先が取得できます。

	*b = 2;			// ポインタ型変数の前に*を付けると参照先の実体を手繰り寄せます。これにより、bがaの値そのものをさすことになるので、
					// aと*bが共に1から2へと変わります。

					// ざっくり言うとポインタってのはこういうものです。それ以上でもそれ以外でもないです。
					// で、終わらせたら悲しんじゃう人がいるでしょうから、この後の関数で少しずつ述べますか。
}

/**
* @brief		引数を2倍にします。実用性0
* @param[in]	n    2倍にする元の値
* @param[out]	なし
* @return		引数を2倍にした値
* @detail       briefに全部書いてる。
*/
static int Double(int n)
{
	return n * 2;
}
/**
* @brief		Double関数を使ったり、それ以外を説明するためのもの
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample41Func2(void)
{
	// それじゃ、まぁシングルポインタをどう扱うかです。
	char str[] = "hello\n";	// これはご存知？char型配列の宣言と定義です

	// 既に↓は目に見えない形でポインタを使ってます。
	// printfは関数プロトタイプがint printf(const char*, ...);です。
	// あれあれ？第一引数がchar*(char型のポインタ)になってますね。これはどういうことでしょうか？
	printf(str);

	// 実は宣言とかいくつかのことを除いて配列は全てポインタに置き換えられてしまいます。
	// ※だから今はポインタ演算が大抵早くならないのですが。昔は最適化がショボいので差がでることがあったんです。
	printf("%c\n", str[2]);
	// ここにあるstr[2]ですが *(str+2)の糖衣構文です。んで、*(str+2)ってのがいわゆるポインタ演算ってのですね。
	// そして、配列は片っ端からポインタに置き換えられているので他の変数と違って、これまた糖衣構文が存在します。
	// 上で書いてるprintf(str);がそれです。これはprintf(&str[0])と同じです。
	// へ？なら途中から表示できるのって思うかもしれません。当然できます。
	// 2文字目から表示するならこうです。
	printf(&str[1]);

	// えーとですねシングルポインタってこのように配列を扱う場合ばっかりなんですよ。えぇ
	// それ以外だと次に書く関数ポインタですか。
	typedef int(*Func)(int);
	Func func = Double;
	printf("return value = %d\n", func(10));
	// 最初のtypedefが泣き所なんですが、関数ポインタに限ってはtypdef 古い名前 新しい名前じゃないんです。
	// typdef 戻り値(*関数ポインタ名)(引数)なんです。これはtypedefを使わない関数ポインタを書けばすぐわかるのですが、
	// まぁ普通仕事ではtypedefされたものしかないでしょうから、無視しておきます。
	// で、Func func = Double;ですが、思い出してください。ポインタって何を参照するんでしたっけ？
	// 被参照型(関数型、オブジェクト型または不完全型)ですよね？ここにある関数型なんですが、C言語では関数も
	// 型を持っていることになってます。
	// で、これまた糖衣構文により&つけなくてもfuncはSample41Func3の参照として割り当てられてます。
	// 割り当てられたので次のprintf中で引数10を渡して戻り値を表示することが出来ます。
	// C言語って古い言語は実は変数に関数を割り当てて自由に使うことが出来るようになっています。これの応用は
	// その内書くかもしれませんが。

	// あとは複雑なデータ構造で使うのと標準ライブラリや自作の関数の引数とかで渡す方法位です。
	// 引数で渡すのはこの後書きますね。
}

/************************** 関数(値渡し、ポインタ渡し) ***************************/
// 複数の関数と構造体を説明用に定義しているので、ここはDoxygenスタイルのコメントは付けません。
// 一つ一つの関数にはほぼ意味がないので
void Value(int);
void Pointer(int *);
typedef struct {
	int a;
	int b;
} Test;
void Structure(Test *);
void Array(int *);
void String(const char *);
void StringPerfectGuard(const char * const);
void Sample41Func3(void)
{
	// 引数の値渡しとポインタ渡し
	// 実はC言語は値渡ししか出来ません。なのでポインタを使用して実体(厳密には違います)を渡すというのがポインタ渡しです。
	// ↓を見ましょう
	int a = 20;
	Value(a);	// これは今までと同じですね
	Pointer(&a);	// おや？これはaの前に&が付いてますね。ということは引数のポインタにでも参照を割り当てるのでしょうか？
	printf("a=%d\n", a);	// Pointerの中でaを変更してるので、値が変わってます。

	// ポインタ渡しは2つ用途があります。
	// 一つは戻り値が一つしかない関係上、引数に戻り値以外の変数を渡し、変更してもらう場合です。↑のサンプルは引数1つですが、
	// 複数変更してもらうにはポインタ渡しするしか方法がありません(その場合、構造体を使うのを推奨)。
	// もう一つはこの後述べる構造体や大きな文字列のコピー防止です。

	// 構造体のポインタ渡し
	// 構造体に限らず長い文字列などを値渡しで関数に渡したりするとコピー処理というのが発生します。
	// ま、そのおかげで渡した元の変数は何があっても、変更されたりしないのですけど。
	// で、そういうコピーってサイズが大きいと時間がかかるので、速度低下を防ぎたい場合ポインタを渡しちゃえばいいじゃんってのがあります。
	// ポインタ渡しならコピー処理が起きないのです(だって大本の変数のアドレス渡すだけなので(厳密には語弊あるけど無視))。
	// ただ、そいうのを細かく考えたくないってのがC言語以外が好きな方でしょうから、
	// intとかの基本型？は値渡しで、文字列とか構造体は何も考えずポインタ渡しとしてもLv5なら問題ないかなと

	// 余談なんですけど、
	// JavaとかC#とかってので参照型(C#の用語でJavaは違うんだったっけ？)を引数に渡すことがあると思います。
	// 実はあれ全部ここでいうポインタ渡しです。記載上そうなってないだけで全部ポインタ渡しです。
	// ※そりゃオブジェクト指向とかGCが関係するので、そうなっているのは分かるのですが。
	//   おかげで変更できないインスタンスとしてイミュータブル(綴り忘れた)なんて考えが必要になるわけですし。
	Structure(&(Test) { .a = 11, .b = 12 });

	// ちなみに配列の場合、配列が即座にポインタに置き換えられてしまうことから、少し事情が異なります。
	int array[] = { 1,2,3,4 };
	Array(&array[0]);	// もちろん前に説明したように0から渡すならarrayだけでOKです。ただ、私この表記が好きな人知ってるんですよねぇ。
	printf("array[1]=%d\n", array[1]);

	// で、最後に文字列のconstガードです
	char str[] = "あかさたなはまやらわ";
	String(str);
	StringPerfectGuard(str);
}
static void Value(int a)
{
	// こっちは今まで通り
	printf("args=%d\n", a);
}
static void Pointer(int *a)
{
	// む？引数に*が付いてますね。ということは引数はintのポインタってことでしょうか？
	// はい、そうです。呼び出し側で&aとしてましたよね？
	printf("args=%d\n", *a);

	// *を付けて実体を手繰り寄せると、呼び出し元の変数値を変更することができます。
	// これは値渡しでは出来なかったことです。
	*a = 15;
}
static void Structure(Test *data)
{
	// 構造体の場合、アクセスする時は->でメンバを手繰り寄せます
	printf("value a=%d b=%d\n",  data->a, data->b);

	// ->ってのは(*変数名).の糖衣構文です。でも普通->を使うので忘れて構いません。
	// ただ、このサンプルでは複合リテラルで呼び出してるので↓に意味はありませんがね
	data->a = 15;
	(*data).a = 20;
}
static void Array(int *array)
{
	// 配列の場合に限りませんが、こんな感じでアクセスできます。
	printf("array[0]=%d\n", array[0]);

	// 書き換えるのもこうです
	array[1] = 10;

	// これ昔の名残でポインタ演算で書かれることがあります。
	// が、意味ないので皆さんが組む時は、配列表記のアクセスでいいです。むしろ、それしか使うな
	// 現代では早くもならないし、そんなの読める人が減ってるので保守性が低下する。
}
static void String(const char *str)
{
	// 文字列が大きいのでポインタで渡したいが、中身を書き換えられたくない場合に
	// constをchar *の前につけることがあります。
	// で、こうすると確かに↓はコンパイルエラーになります。
	// str[1] = 'a';

	// が実はstrが指す変数の実体が書き換えれないだけで、str自体を書き換えることは出来てしまいます。
	// これ知らない人が多いのですが。。。
	// でもまぁこの関数内だけで有効な変数を書き換えるだけなら、あまり問題ないかもしれません。
	// けど、この関数が非常に長くて、後から触る人間が他人だとどうでしょうねぇ
	str = NULL;
}
void StringPerfectGuard(const char * const str)
{
	// そんなわけでstr自体も参照してる先も書き換え不能にするなら↑の表記になります。
	//str[1] = 'a';
	//str = NULL;
	// しかし、まぁ普通はconst char *の表記しか使わないでしょうから、
	// 知識として知っておけば良いのではないかと
	// なぜなら、1.知らないから 2.知ってても引数の型が長くなって見にくいから 3. 2.によってプロジェクトのコード規約で書くのが大変だから
}
// 一つだけ大事なことを
// ポインタ渡しをする場合、NULLという存在(本当は無効なポインタもあるが、それを明示的に確認することは不可能)がネックになります。
// NULLはこの後にも登場しますが、どこも参照先がないポインタだよなんて意味です。
// 実はNULLについては非常に細かい話があるのですが、Lv5なので省略します。
// で、何が問題かというとNULLにアクセスすると大抵プログラムが強制終了します。
// なので全メンバで意識共有できていない限り、NULLチェックがどうしても必要になります。↓みて
#if 0
void Array(int* array)
{
	// もし引数がNULLなら処理を行わず、returnする。
	// ただ、この場合エラーログを出すとか戻り値で呼び出し元に教えてやるのが正解だと思います。
	if (array == NULL)
		return;

	// もし、NULLチェックせずに↓の処理を書いてると、うっかり引数にNULLが渡されたとたん強制終了します
	printf("array[0]=%d\n", array[0]);
}
#endif

/************************** 動的確保 ***************************/
/**
* @brief		動的確保の説明用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample41Func4(void)
{
	// ほんじゃ、まぁ動的確保をやっておきましょう

	// 周知の事実として、最近の言語と違いC言語は基本的なデータ構造をライブラリで持っていません。
	// 基本的なデータ構造というのはリストやスタック、ハッシュといったものです。
	// で、動的確保というのは基本的にこの基本的なデータ構造を実現するのに必要と思っておけばいいです。
	// 普段組むものでは、ほとんど必要性がありません。少なくとも文字列を正規表現風に解析したり、
	// サイズが分からないファイルを読み込んで処理するとかじゃないと。
	// ※あと一つ、組み込みとかで良く使われている巨大な構造体だとスタックオーバーフローすることがあるので、
	//   仕方なく使うことがあります。その巨大なデータがうまれる背景は省略で

	// 逆にC言語はライブラリが貧弱だから、生産性が悪かったりします。
	// そして、まだ私は仕事でみたことないですが、そういった基本的なデータ構造をライブラリ化したものを各会社
	// 用意してなかったりします。バカじゃないの？とは思いますが。
	// そこが弱点で何年、何十年とC言語で組み続けてるのに基本ライブラリがないとか・・・

	// そんなわけで初心者が苦しむのは現代の言語では、ほぼやらないこの基本的なデータ構造ライブラリを各会社の
	// 仕事の度に用意することかもしれません。
	// C++だとSTLってもんと参照って概念であまりポインタとお付き合いしなくて済むのですがねぇ。

	// 前置きが長くなりました。では、始めます。
	// ちなみに動的確保はC言語の予約語にはありません。ライブラリによって実現されています

	// NULLというのが↓にありますが、これはまだ何も参照先が割り当てられていないポインタだよってのを表すリテラル(定数みたいなもん)です。
	char *p = NULL;
	// ↓これでcharの領域10個分が確保されます。mallocの戻り値はポインタで受けて下さい。
	p = malloc(sizeof(char) * 10);
	// これは余談ですがsizeof(char)は1しか返さないことが規格上決まっているので、今回はsizeofしても意味が・・・ね
	// あとmallocは領域確保に失敗するとNULLを返してきますが、ここではチェックしていません。
	// ※静的解析ツールを使う職場だと、その時点で警告食らうでしょうね
	// というか、mallocがエラーを返すのは一度に0x7fffffff位のサイズを要求するとか、本当にメモリがないとかなんですけどね。

	// mallocという関数で動的な領域を確保します。引数は確保する領域のサイズです。
	// 戻り値はvoid*というどんなポインタ型も入れれるポインタを返してきます。
	// 大昔(C89以前)はvoid*がなかったのでchar*を返してました。そのせいで
	// p = (char*)malloc(sizeof(char) * 10);という書き方をするコード、人がまれにあります。
	// でも、今はvoid*なのでこんな無駄なキャストは絶対にやめて下さい。
	// ※サイトによってはC99以降と書いているところもあるが、void*からT*への暗黙の型変換はC89からOKだったはず
	//
	// ただし、次の違う2つの理由でキャストを薦める人たちもいる。
	// 1. C/C++の両方でビルドできるようにするため
	// 2. 間違えたサイズをmallocに渡した際、警告を出してもらうため
	//
	// 私の意見では、1.に対しては大反対です。現在のC++はベターC言語といったものではないので、むしろどちらとしてビルドするのかはっきりすべき
	// だと思っています。
	// 2. は確かに有用なケースもあるかと思う。
	// だけど、これを行いたい場合はJPCERTのページに書かれているようなマクロ(次の記載するもの)を使うべきだと思う。だから直接手書きするのは反対かな。
	// #define MALLOC(type) ((type *)malloc(sizeof(type))) // 単体で確保
	// #define MALLOC_ARRAY(number, type) ((type *)malloc((number) * sizeof(type)))	// 配列で確保

	// そして不要になった領域を解放するのはfreeです。解放してないとメモリリークします。
	// プログラムが生きている間だとね。
	free(p);	// free(不要になったポインタ);ですな
	// んでこれたまに知らない人がいるのですが、freeはNULLのポインタに対して何も処理を行いません。
	// なので最初にNULLを入れておくとmallocに成功しようが失敗しよう(失敗したらNULL入りますし)がfreeで解放できます。
	// それを知らなくて、↓のようにする人がいますが無駄です。
	// if (p != NULL)
	//     free(p);

	// で、freeした後の領域に触ってもすぐに解放されるわけじゃないのでバグが見つけにくくなります。
	// なのでfreeしたら変数にNULLを入れ、もし後続の処理で触ったらメモリ保護違反を起こすように書くのがお約束です。

	// あ、そういえば他にcallocとreallocってのがありましたね。
	// んでも、この2つ忘れていいです。
	// callocを推奨する人もいますが、私はそんなもの使っても意味ない派です。だから無視します。
	// で、reallocなんですけど。うーん、reallocする位なら、リストとか用意して使った方が無難だと思います。
	// 正しく使うのが難しいライブラリでもありますし

	// これらを踏まえて実践での推奨記法を次の関数に書きます
}

void Sample41Func5(void)
{
	// Test構造体を使いますね。他の人はどうか知りませんが、私は確実に解放もれさせないため、こう書きますね

	// 変数用意と領域確保
	Test *p = NULL;
	p = malloc(sizeof(Test) * 20);
	if (p == NULL) {
		goto CLEAN;
	}

	// 悩ましいのは初期化でしょうね。初期化関数を作るのもありですし、↓のようにしてもいいし、
	// バイナリデータを格納するだけならmemsetって関数使うのもありと言えばありです。
	// なぜ、悩ましいかというと構造体の中に小数(float&double)とかポインタがある場合、memsetで0初期化しても
	// データが0.0とかNULLになる保証はないからです。それだったら私は複合リテラルで良いのではと思う次第
	for (int i = 0; i < 20; i++) {
		p[i] = (Test) { .a = 0, .b = 0 };
	}

	// 代入と表示
	p[2] = (Test) {.a = 11, .b = 12};
	printf("replace! a=%d b=%d\n", p[2].a, p[2].b);

	// 絶対に成立するifですが、まぁ実際だと何かのエラー処理があるということで
	if (p[2].a == 11) {
		// 処理を続けれないエラーが起きた!
		goto CLEAN;
	}

CLEAN:
	// 正常、異常時を問わない解放処理
	free(p);
	p = NULL;
}

/************************** restrict ***************************/
void RestrictPonter(void * __restrict, const void * __restrict, size_t);
void Sample41Func6(void)
{
	// 一応落ち葉拾い的にrestrictを捕捉しておきます
	// 悲しい事実ですが、restrictって構文はVSで使えません。使うなら独自拡張扱いの__restrictです。

	// restrictは指定された引数にエイリアス(このポインタは絶対に他の変数と重複してません(ちょっと意訳))を
	// 宣言します。
	// 実はポインタを引数にした場合などでは、コンパイラは他の変数と被っていないことが分からないため、
	// 最大限の最適化が行えません。その辺が色々問題となるのでC99でこのrestrict追加したから最適化がんばれー
	// というものです。

	// でも、VSだと積極的に使った所で本当に最適化頑張るのかなぁ？
	// C99で変更になった関数のプロトタイプ宣言にも変更してないし・・・
	// ま、他のClangとかgccでは積極的に取り入れられているので、無駄にはならないと思います。

	char copy[32];
	char original[] = "おはようございます";
	RestrictPonter(copy, original, _countof(original));

	printf("%s\n", copy);
}

static void RestrictPonter(void * __restrict dst, void * __restrict src, size_t size)
{
	// おいおい。VSさんよ。なぜmemcpyをC99のrestrict付きにしてないのよ。。。
	memcpy(dst, src, size);
}

/************************** 関数(ポインタ渡し おかわり) ***************************/
// 学校等がそう教えているのか分からないが、良く"ポインタってアドレスですよね？"という感じで覚えている人がいる。
// で、これはC言語編ということもあり、ポインタ渡しという'俺流造語'?(一般的？)を絡めてもちっとだけ詳しく記載します。

void pointer1(int);
void pointer2(int*);
int *pointer3(int*);
void pointer4(int**);

/**
* @brief		ポインタ渡しを少し深く説明する用
* @param[in]	なし
* @param[out]	なし
* @return		なし
* @detail       briefに全部書いてる。
*/
void Sample41Func7(void)
{
	// まず、ポインタはアドレスでしょって考えの人、きちんと理解した上でそう言っているなら問題ないが、
	// 大抵その考えだとドツボにはまる気がする。
	// 多分 printfの%p辺りで表示させた時にアドレスが表示されるのでそう思い込んでいるのだろうが、
	// 関数内で動的確保し、引数に設定するといった処理で頭がとっ散らかると思う。(そういうもんだと表面上だけ納得するかもしれんが)

	// でだ、ポインタ渡しって言葉を書いているが、そんな言葉はC言語に存在しない。
	// 関数に渡す時は値渡しだけだ。変数なら値をコピーして渡すし、ポインタならポインタのコピーを渡してる。

	// なにも言わず下を見てくれ
	int a = 10;
	printf("Before pointer1 a = %p\n", &a);
	pointer1(a);
	pointer2(&a);
	// 多分pointer2の表示と上の&aの値が同じになることから、
	// "ほらやっぱりコピーされずに渡されてるじゃん"とか早合点したりすると思う。
	// そう思ったそこの君。マテ、待つんだ！
	// では、関数内で値を変更するとき どうして*をポインタに付けるんだね？そして次の処理をみたまえ。
	int b = 11;
	int *pb1 = &b;
	int *pb2;
	printf("Before pointer3 pb1 = %p\n", pb1);
	pb2 = pointer3(pb1);
	printf("After pointer3 pb1 = %p\n", pb1);
	printf("After pointer3 pb2 = %p\n", pb2);
	// どうだい？pb1は呼び出し元の内容変わってないだろう？ポインタもコピーして値渡ししてるんだよ。
	// 関数内で*をつけるのは参照先を手繰り寄せるためだよ。じゃないと中身を変更できないんだよ。
	// ※ というかポインタだから、コピーを値渡ししても*で変更が可能なんだ
	//
	// int *のポインタ変数に参照先を設定し、値を設定するときは*をポインタ変数につけて設定する。
	// ※ ポインタ宣言と参照先を手繰り寄せる時の記号が共に*なのは困ったちゃんだが
	//
	// これだけのことを変に"ポインタはアドレスだから"とか考えていると、応用するときに苦しむように感じる。
	// もちろん複雑なデータ構造を自作するとか、デバイスドライバみたいにアドレスを意識しないといけない場合は別だが、
	// 普通に使う場合はポインタがアドレスなんて考える必要性がないと思う。

	// 下は関数内で動的確保してもらう場合だが、どうして引数をダブルポインタにする必要があるんだろうね？
	int *c = NULL;
	pointer4(&c);
	free(c);
	// これをポインタはアド・・・なんて考えると必要以上に苦しむ羽目になる。
	//
	// 単純にポインタを関数に渡し、関数内で*を付けずにmallocの戻り値を設定するとポインタのコピーなので意味がない。
	// *を付けてmallocの戻り値を設定すると、ポインタの参照先にデータが設定されるのでポインタに設定してるわけじゃない。
	// それ以前に参照先を設定していなかったりNULLだった場合、どういう挙動するか分かったもんじゃない。
	// じゃ、どうするんだ？
	// ・・・あ、ポインタをさらに"ポインタ渡し"してやれば、関数内で*付けると呼び出し元のポインタが手繰り寄せれて設定できるじゃないか！
	// と考えるだけで良し。アドレスがぁー、コピー先がぁなんて考えると混乱するだけだ。
	// ※ 使いやすいので俺流造語のポインタ渡しをあえて使うｗ
	//
	// それにさ、アドレス、アドレスっていうのなら本来下ってビルド通るよね？
	// *(0x000000C8BCCFF6F4) = 10;
	// なんでエラーになるかっていうと左辺がポインタじゃないからだよね。ポインタ(↓)だと警告はでるけどビルドは通るもんね。
	// int *d = 0x000000C8BCCFF6F4;
	// *d = 10;

	// こんな感じでC++編だと滅茶苦茶誤解を招きそうなノリで、C言語編では少しだけ詳しくポインタを渡すことについて書いてみた。
	// でも、実際はそこまで理解してない人も多くてそれで成り立つし、アドレスって考える方がややこしいことが多い気がする。
	// それにアドレスって考えるのが嫌な最大な理由は、"そもそもC言語の文法に沿っていないと同じ文脈でアドレスを使ってもポインタと動きは異なる"から。
	// 抽象的な考えで覚えないとLv5の人が"関数ポインタはアドレスでぇ・・・"なんて、禅問答に突入しそうだけどねぇ。
}

// ここは説明用でひどいからDoxygenコメントなし
void pointer1(int p)
{
	// 多分ここで表示されるpはSample41Func7の値とは異なるだろう
	printf("pointer1 p = %p\n", &p);
}
void pointer2(int *p)
{
	// 多分ここで表示されるpはSample41Func7の値とは同じだろう
	printf("pointer2 p = %p\n", p);
}
int *pointer3(int *p)
{
	printf("pointer3-1 p = %p\n", p);
	p = p + 1;
	printf("pointer3-2 p = %p\n", p);
	return p;
}
void pointer4(int **p)
{
	*p = malloc(sizeof(int));
}
