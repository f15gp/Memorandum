/**
**********************************************************************
* @file		Sample2-1.cpp
* @brief	浅くC++言語 を学ぶためのサンプル2-1(実装)
* @date		2020/08/18
* @par		Copyright
  (c) 2019-2020 Bunya
**********************************************************************
*	@par	History
*			- 2020-08-18 Bunya
*				-# 新規作成
*
**********************************************************************
*/

// サンプル 2-1
// 大枠：列挙型、構造体、制御(if, 繰り返し)、typedef、using、namespace再び、例外、(嫌だけど)動的確保
// 命名規則：原則スネーク記法

#include "Sample2-1.h"

#include <iostream>		// ちょっと表示したいので
#include <algorithm>	// |дﾟ)見せでstd::for_each使うので
#include <vector>		// 同じく|дﾟ)見せ
#include <array>		// やっぱり、ry)

#include <cstdlib>		// malloc使うので。。。

// 名前空間を説明したのでここからは
// 関数丸ごとパック？するので行きます
namespace sample2_1 {
#pragma region 列挙型
	// 列挙型。古い書き方は無視
	// 最後のcharはこのColorをcharの値を持つと指定している(昔の規格ではこの型の規定がなかった)
	enum class Color : char
	{
		Red = 10,
		Blue,
		Green
	};

	/// <summary>
	/// 列挙型サンプル。以上
	/// </summary>
	void func1()
	{
		Color c; // C言語と違ってenum Colorと型を宣言する必要なし。よってtypedefでの置き換えも不要
		c = Color::Blue;	// 警告対策ｗ ついでに新形式のenumは名前空間を持つ(C++03では名前空間を持ってなくて苦労した)

		//int a = Color::Green;	<- 暗黙の型変換禁止
		int a = static_cast<int>(Color::Green);	// 明示的な変換はOK。
	}
#pragma endregion 列挙型

#pragma region 構造体
	// 構造体。これはクラスと何が違うんですか？と言われると、ほとんど変わらない。
	// 指定がなければ全メンバ(↓のa, bのこと)がpublicという形で公開されているだけ(classはデフォルトでprivate)
	// なので正直言うとわざわざ使う必然性はない。
	// ただ、この構造体はデータを扱う専用のものですよ。と、明示するのに良いかなと思ってオイラは使っている
	struct Struct
	{
		// PODとか初期化の関係がC++は極めて複雑なので、
		// きちんと知らない人は構造体、ローカル変数、クラスの変数をすべて必ず初期化しておくことを推奨する
		// 初期化は。。。どこかで書くかも。。。でも、激しく複雑なので、Lv5で書くにはかなり後かなぁ。。。
		// ちなみに↓はメンバの初期化に相当するんですが、C++03では不可能な書き方なのでご注意を
		int a = 1;
		int b = 2;
	};

	/// <summary>
	/// 構造体サンプル. ry)
	/// </summary>
	void func2()
	{
		// 列挙型と同じくC++ではstruct Structとする必要はない。よってtypedefでの置き換えも不要
		// ...でも今でもtypedefでの書き換えやっているソースは多い。だってC言語の知識のままの方多いですから
		Struct c;

		// メンバへのアクセスは.演算子。ポインタ変数経由なら->演算子となる
		c.a = 10;
		c.b = 20;

		// 構造体の初期化
		// C言語あがりの人や良く知らない人はmemsetというC言語の関数を使うことがあります。
		// はっきり言います。やめろ、バカ野郎です。
		// POD以外の構造体に適用すると厄介なバグを引き起こすことがあります。
		// そしてクリア対象のサイズを間違えると一発で領域破壊ができます。
		// きちんと全メンバを初期化しているか初期化を正しく知っている人なら↓で良いのです。
		c = Struct();

		Struct d = { 0 };
		// ↑だと、aが0でbに初期値が指定されていればその値。指定されてなければ0として初期化されます。
		// これは集成体型(配列とか構造体)全般に適用される話です。
		// C言語では構造体メンバの初期化値が与えれないので、{0}での初期化は良く使います。
		// ※ C言語でも全メンバを指定するかC99以降の指示付き初期化を使えば可能。でもC99って・・・
		// memset使う人も大半が0初期化に使うので、この書き方を知らないのかな？と疑ってしまいます。慣れで書いてる人もいますけど、知らん人も多い

		// また、構造体同士の代入、戻り値で返す、引数に渡せれるということを知らなくて、
		// memcpy, strcpyとか言うC言語の関数を使って代入したりする人が結構います。
		// もちろんこれもやめろ、バカ野郎です。
		// どういうことかというと、こういうことです
		struct e
		{
			int i = 1;
			// [7]は配列の要素数を指定。Cのchar配列での文字列は文字数(1byte文字限定)+\0で7.
			// \0で文字列が終端するのが鉄則.
			char str[7] = { 's', 'a', 'm', 'p', 'l', 'e' };
		};

		e f;
		f.i = 20;

		e g = f;
		// ↑これができることを知らない(これはそもそもC言語ですら出来る)のかmemcpyを使うって話です。
		//   酷い場合、g.iにf.iを代入して、g.strをf.strにstrcpyしたりします。
		//   memcpyの場合、実数で問題が起きたりします。0.0がall bit 0とは限らないからです。ま、使わなきゃいいだけ
		//   memcpyを使う人の言い訳の代表に"この方が早い"というのがありますが、作成される機械語は全く同じなので、嘘です。
	}
#pragma endregion 構造体

#pragma region if_繰り返し
	/// <summary>
	/// if 繰り返し を述べちゃうぞっと
	/// ついでに配列も述べちゃったりして
	/// </summary>
	void func3()
	{
#if 0
		// 配列。初期化する場合の要素数と初期値が固定の場合は、↓で
		int array[]{ 10, 20, 30, 40 };	// 要素数はコンパイラが自動計算
										// でも、初期化する場合に要素数が分かるがすべての初期値が分からない場合は↓で
		int array[4]{ 10, 20, 30, };	// 4要素を確保。指定されていない4つめの要素は0初期化されることが決まっている
										// 配列の要素数はconst変数が使えるので、↓の宣言はC++ではOK
		const int elements = 4;
		int array[elements];
#endif
		// ただね。配列は後から述べるstd::arrayで良いと思う。なぜならこいつは要素数を覚えてくれて、範囲外アクセスも見れるから。
		// 配列は、C++03だとアルゴリズムというのを適用しにくいというのはあったが、C++11以降では生の配列への適用も簡単。
		// ※(arrayが入る前のvectorというものの話)[]に比べて、.at()が要素のサイズオーバーを検出して例外をだすものになるのだけど、
		//   at()は、ひと昔前は例外を出したり検査するので少し遅いということで皆[]ばかりを使ってました。(at()の存在そのものを知らないなど思いたくない)
		//   今は[]と.at()がconstexprというものになったし、速度ペナルティなんてほとんど考える必要ないです。
		//   よってこれからは.at()使いまくりで問題ないです。逆に極小の速度ペナルティを
		//   理由に[]でのアクセスを守る人の場合、メモリ保護違反を出したら罰金位にしちゃえば良いんじゃないかと。
		//   そういう人は[]での範囲外アクセスを甘くみてるか、大規模開発とは何かを分かってなさすぎなので
		//
		// で、動的配列(要素が増えたり減ったりする配列。C#でのListとか)の可能性があるなら、std::vectorを使うこと。
		// ポインタでもってnew or mallocなんてしたら、死ねの一言です。
		// (現在vectorは.data()でポインタみたいなもんが手に入るので、古い関数へのポインタ渡しも余裕。書き換える場合は勘弁して)
		// ぶっちゃけ言うとstd::vectorが速度、メモリ効率共に優秀なので、配列もstd::arrayもstd::listというのが適してそうな場面でも、
		// 考えたくないからという理由でstd::vectorにすべて統一する人もちょくちょくいます。
		// ま、保護違反でソフトが落ちる位ならそれも悪くないと思います。
		// というかそのくらいstd::vectorは性能が優秀

		// ifを述べちゃうぞ。でも他の言語とほぼ同じなので。。。
		// 一応C言語を母体にしてるのでC++でも0(=false) か 0以外(=true)かで判定を行います。
		// ま、それだけなのでソースに書くほどでもない

		// 繰り返しはfor, while, do-whileがあります。他の言語と同じですな。
		// while, do-whileは同じなので、
		// 普通のfor, range-based-for, 細かいことは説明しないけどstd::for_eachを紹介
		// あ、イテレータってのがありましたな。サラッとだけ最後に書いておくかな

		std::vector<int> vec{ 1, 2, 3, 4, 5 };		// 統一初期化構文ってのを使ってのvector初期化
		std::array<int, 5> arrays{ 6, 7, 8, 9, 10 };// 同じくarray(変数名に対して、英語の複数形の規則は無視してますがね)
		int old_array[]{ 11, 12, 13, 14, 15 };		// 配列

		// 普通のfor
		for (std::size_t i = 0; i < vec.size(); i++) {
			// vecの内容を全部表示。この場合、絶対サイズオーバーしないので[]でも。。。いやいや、at()で。
			// ・・・でも例外説明してないから例外には備えてないのよなｗ
			std::cout << vec.at(i) << ' ';
		}
		std::cout << std::endl;

		// range-based-for
		// もしarraysの要素を変更するならauto&&で。intだから値渡しで十分でしょうが、統一的にconst auto&で
		for (const auto& element : arrays) {
			// arraysの内容を全部表示。arraysの要素は1つずつelementに格納される
			std::cout << element << ' ';
		}
		std::cout << std::endl;

		// std::for_each(理解するには、もっと先で説明する内容が必要)
		// まぁ、全要素にアタックしていくならrange-based-forでも良いのだけど、
		// std::for_eachは指示した始点から最後までなめていってくれますから
		std::for_each(std::cbegin(old_array), std::cend(old_array), [](const auto& elem) {
			// ここはラムダ式
			std::cout << elem << ' ';
		});
		std::cout << std::endl;

		// ただ、まれにforにおけるループ変数の寿命を誤解してる方がいます。
		// これはVC6(1998年発売だった気がする。もう20年以上前かぁ)というものの弊害なのですけど。。。
		for (int i = 0; i < 10; i++) {
			// 変数iはこのループの中でのみ有効。ループの外に出るとiは無効となる。
		}
		// int j = i; <- これだと、iが定義されてないと怒られる。

		// ちなみにC言語でもC99では変数をどこでも宣言できるようになり、↑のforのint iはC言語でもfor内だけの
		// スコープになりました。C言語でそのようなプログラムを書いたのを見てレビュー指摘したら、
		// 今は赤っ恥を書くことになるのでお気をつけを(C89, 95縛りにしてたら別ですが)。
		//
		// また、C++ではC言語と違って、変数は実際に使われるタイミングで初期化されることに変わっています。
		// なので変数は実際に使う場所付近で宣言する方が理にかなってます。C言語を引きずってブロックの先頭に
		// 宣言を集めたら、下手をすると老害扱いされるかも？
		// まぁここはスタイル宗教になりかねないので、どっちでもいいですけど

		// イテレータ
		// あれです、デザインパターンとかに出てくるイテレータパターンの奴です。
		// 一応柔軟な使い方も出来ますし、知っておくと便利に使える場面もあります。
		// それとC++03だとこのイテレータを多用せざるを得なかったというのもあります。
		// どうして今すたれているのか昔スタイルで書いてはっきりさせます。
		std::vector<int>::const_iterator cItr = vec.cbegin();
		std::vector<int>::const_iterator cEnd = vec.cend();
		for (; cItr != cEnd; ++cItr) {
			std::cout << *cItr << ' ';
		}
		std::cout << std::endl;
		// 単純に言うと、まずautoを使わない場合、型が長すぎるからです。
		// まぁ、これはIDEの補完機能とautoがある今ではそう問題でもないでしょうが。
		//
		// あと、イテレータはキチンとした型を持っていますが使い方がポインタそのものなのです。
		// また、++cItrって珍しい書き方してるのは後で述べる一時オブジェクトってのが関係します。
		// そんで廃れている理由は、auto & range-based-forで賄えるし楽だからというのが大きいです。
		// さらに言えばこのイテレータは基本的にポインタで実装されることが大半ですが、問題なのはこのイテレータ
		// 簡単に無効なイテレータ(ポインタで言うところのnullptr)になってしまうからです。
		// それが分かっていて組んでいるなら問題ないですが、分かってなければテスト不足でアプリごと落ちるなんてコードが
		// 簡単にできちゃいます。(これはrange-based-forでも一部あるけど、そのためにfor_each使うのもなぁ。。。)

		// ただ先頭からでなく最後から先頭に向かってループするためのreverse_iteratorというのがあるので、そういうレアな場合は便利です。
		// でも、のちに述べるかもしれないrange-based-forの規則さえきちんと分かればreverseでさえ、range-based-forで済んでしまいます。

		// よって、イテレータをループで使うことはかなり減少しました。
		// 使うのは↑で述べた for_eachだったりfind_ifなどのアルゴリズムと呼ばれるものと、eraseなどを使う場合が主です。
		// ま、find_ifはとにかく良く使うし、ラムダ式との相性抜群なので後で記載予定。
	}
#pragma endregion if_繰り返し

#pragma region typedef
	// typedefってのは名前の付け替えと思っておけば間違いないです。
	// あまりC++では必要ない気がしますけど、業務ソースでC言語が混じっていると頻出するので仕方なく
	// ↓な感じ(typedef 古い名前 新しい名前)
	typedef int INT;	// INTをintってのに置き換えます。(と言っても、プリプロセッサじゃないからコンパイル時に入れ替える)

	struct type
	{
		int a;
	};

	/// <summary>
	/// typedefの説明用。引数同士を掛け算して結果を返す
	/// </summary>
	/// <param name="x">引数1</param>
	/// <param name="y">引数2</param>
	/// <returns>引数1と引数2を掛け合わした値</returns>
	static int function_pointer(int x, int y)
	{
		return x * y;
	}

	/// <summary>
	/// typedefってのを紹介
	/// </summary>
	void func4()
	{
		INT a = 10;

		// C言語のソースではstructを例えばこのようにする必要があります。
		// ※ C++じゃ先頭のstructは必要ない
		struct type b = { 0 };
		// C言語では、このstructを付けるのが面倒だからか、
		// typedefでの付け替えがお約束です。
		// その際は構造体宣言をちょいと変えて↓のようにしてます。
		typedef struct {
			int a;
		} type_replace;
		// すると、
		type_replace c = { 0 };	// C++と同じように宣言できる！
		// でも・・・やっぱりC++じゃstruct必要ないんで ry)

		// あと凶悪な、そしてしばしば使う必要のある関数ポインタでtypedefは大活躍でした。。。
		// そう、過去形なんだけどね
		// こんな風に書きます
		typedef int(*pfunc)(int, int);		// intを返して２つのint型変数を引数に取る関数へのポインタをpfuncに置き換え
		pfunc d = function_pointer;			// 置き換えられたpfuncの変数dに関数を代入(型が違うと入りません)
		std::cout << d(3, 5) << std::endl;	// 関数ポインタを使う

		// ここで疑問が出るでしょ。(typedef 古い名前 新しい名前)じゃねぇじゃんと。
		// でも関数ポインタに関してだけ、なぜかこのように書きます。
		// typedef int(*)(int, int) pfunc;	こうすると構文解析が難しかったのかしらねぇ。。。
	}
#pragma endregion typedef

#pragma region using
	/// <summary>
	/// using サンプル
	/// </summary>
	void func5()
	{
		// usingはいくつか意味がありますんで、一つづつ

		// using ディレクティブ
		{
			// オイラは別にインテリセンス効くし、なんとも思わないし、名前空間が明確になるので、ほとんど省略しません。
			// ですが "std::毎回書くのダルイよ"ってのも分からなくはない。そんなときは！
			using namespace std;	// これ

			// ↑で名前空間を指定しとけば明示的にstd::を書かなくてもcoutとか使えるようになります。
			// C#の奴と同じですな
			// 有効範囲は↑を書いたブロックの末尾までです。
			// ただ、一番気を付けてほしいのは絶対ヘッダにこれ書いちゃダメよ。名前空間の意味がなくなるから
			cout << "ヘッダに書いちゃダメ、絶対" << endl;
		}

		// ↓のコメントを外せば、↑のブロックで宣言したusing namespaceが無効になってるのが分かるっしょ
		// cout << "エラーになる" << endl;

		// using宣言
		{
			// using ディレクティブと違って宣言の方は、ある名前を現在のスコープ内に取り込むものです。
			// この関数で、cout と　endlだけstd::外したいワンなんて時に使えます。
			using std::cout;
			using std::endl;
			cout << "ほら、省略できる" << endl;

			// ま、詳しく言うとusing宣言とディレクティブは違いがあるんだけど、それは必要になった時調べればね
		}
		//cout << "やっぱり、スコープ抜けたらアウト" << endl;

		// using エイリアス
		// これでもってtypedefをオワコンにしたるｗ
		{
			// typedef long timerと等価の用法は↓です
			using timer = long;
			timer a = 1L;
			std::cout << ++a << std::endl;

			using func = int(*)(int, int);		// intを返して２つのint型変数を引数に取る関数へのポインタをusing
			func b = function_pointer;			// usingしたfuncの変数bに関数を代入(型が違うと入りません)
			std::cout << b(6, 7) << std::endl;	// 関数ポインタを使う
			// typedefでこうなら分かりやすかったのにの形そのまんまｗ
			// ちなみにdecltypeと組み合わせると更に簡単(&があれだが)。↓こう
			using decl_func = decltype(&function_pointer);
			decl_func c = function_pointer;
			std::cout << c(5, 9) << std::endl;

			// using エイリアスは可能で、typedefに無理なテンプレートと呼ばれるものへの適用(エイリアス テンプレートっていうんだ)があります。
			// ま、テンプレート自体は後でサラッと書くとして、今回は説明なしで
			// ただ、テンプレート宣言はグローバル、名前空間、またはクラスの中だけしかダメだよと怒られちゃうんで
			// もし↓を実際に動かしたかったら、template<...の行を関数の外に持って行ってね
//			template<class _value> using t_vec = std::vector<_value>;
//			t_vec<int> v;
//			v.push_back(753);
//			std::cout << v.at(0) << std::endl;
		}
	}
#pragma endregion using

#pragma region namespace再び
	namespace A
	{
		const int a = 10;
	}

	/// <summary>
	/// 大枠は説明してるので知ってたら楽になるかもしれない名前空間
	/// </summary>
	void func6()
	{
		// とりあえずネストした名前空間(from C++17)を説明しとこうか
		// ↓みたいに名前空間をネストするんだなぁ
		int a = sample2_1::A::a;

		// で、名前空間の省略ってか別名がここから登場するんだ。昔から使えるけどね
		namespace ns = sample2_1::A;
		// こうするとnamespace sample2_1::Aの名前空間はnsってことになって、
		int b = ns::a;
		// ということが可能になる。

		// 名前空間が長かったら適切な名前に変換できるよってことで
		// いや、まぁ、それだけなんだけどね
	}
#pragma endregion namespace再び

#pragma region 例外
	/// <summary>
	/// 例外
	/// </summary>
	void func7()
	{
		// とりあえずC#とかJavaと同じく例外ってのがある、大きな違いはfinally節がないってこと
		try {
			throw 1;	// 例外投げて
		}
		catch (const int& k) {
			std::cout << k << std::endl;
			// ここでキャッチ。変数使う予定ないなら警告対策で const int& 変数名なしでOK.
			// 細かいことは言わないがスライシングとかの問題あるのでconst 型&で受け取ると良いんじゃない？
		}
		// finallyはない。で、catchしないのは関数飛び越えて、最終的にアプリ終了までたどり着く。
		// finallyなしでどうやって後始末するの？とか思う人いるかもしれんが、C++はRAIIに基づいてオブジェクト
		// のデストラクタってもんでリソース解放してもらうのが原則。だから関数のスコープ抜けたら解放されるように
		// 組むのが紳士の嗜みってもんだ。
		// 極限で言うならgotoもありだ。Javaにだってあるし、ダイクストラ先生もgotoは使うなとは一言も述べてない。
		// goto完全禁止を述べる奴は考えるのをやめたかコピペ坊やだと思う。組み込みならgoto使わないとどうしようもない時あるし
		// なんでって？だって、そもそも例外はmemory allocate必要だから、一部の組み込み用C++コンパイラはサポートすらしてないしね
		// というより、そもそも本当にメモリ不足になったとき、例外はもちろんログを残してなんてのだって出来ないことがほとんど(メモリないのにメモリが必要だからｗ)
		// だから、メモリない状況でもなんとか動くようにって言われると、gotoで飛ばしてfree(or delete)しまくって、必要なことしたら再起動。
		// これの方がよっぽどマシってな状況になっちゃうからねぇ
		//
		// ただし、C++ではgotoが変数宣言を飛び越える場合にかなり制限がかかるので、
		// C++でgoto使う場合よーく注意しておくこと。

		// 継承説明してないってのもあってサラリとだけ
		// 標準で定義されてる例外がいくつもあるので、その辺を継承して独自例外クラス作って使うように多分なる
		// ま、そりゃ継承使えるようになってから各人やってみて

		// あ、そうそう。
		// 例外を外に投げないって指定がありますわ。noexceptってのが。
		// まぁもしnoexcept指定してるのに関数で例外投げちゃったら、std::terminateなんてアプリ即死が起きますけど。
		// 後で述べるコンストラクタやら代入演算子ってので必要になったりしますけどね

		// 余談
		// 余談ですが、関数を飛び越える例外が有効ってのはかなり場面が限定されると思います。少なくともC++では。
		// なんでかというと、例外が受け取れるってのはシーケンシャルな処理をしてるってことだからです。
		// ※ C#のようにAsync系実行時の例外が、eventにより非同期で通知される仕組みが構築されているなら話は別
		//
		// 極端な話、ファイルを開きたいって時にファイルパス渡されていないから例外ってのは、少なくともC++だと違和感あります。
		// ファイルパスがないなら戻り値でその旨を返せばいんです。(皆ファイルを開く時に必ずtryを書くのかと。。。)
		// で、ファイルにアクセスできないから例外・・・これも設計として不味いと思います。(そもそもファイルへのアクセスは非同期なので、アクセスできないこと自体同期的に得ることが出来ないし)
		// なぜかというと、ファイルアクセスは非同期的に行われる(じゃないと、パフォーマンスがでない)からです。
		// だから、結果の通知はオブジェクト指向で言うなら、オブザーバーパターンってことになると思います。
		// 例外を使える or 使ってしまうってことは、そこで処理を待機できる(=シーケンシャルな処理)ってことです。
		// でも、それだとI/Oが絡むとかサーバーとかDBとか、なんらかの待ちが発生する場合に具合悪いですよね？
		// 大事なのはなんでもかんでもエラーを例外で済ますじゃなくて、状況というか設計して最適な方法を考えることじゃないかなぁ・・・
		//
		// それと様々なところから使用されるライブラリ？だと例外投げないでほしいって現場はかなりあると思う。
	}
#pragma endregion 例外

#pragma region (嫌だけど)動的確保
	/// <summary>
	/// 嫌だけど、現実には存在するので触りだけ動的確保を
	/// </summary>
	void func8()
	{
		// ま、あんま使わないでね

		// C言語の癖を引きずって未だに使う人がいるmalloc。でも絶対C++では使うな。
		// 理由はね、mallocを使うとコンストラクタが呼ばれないから

		// とりあえずchar 10個分確保してみようか
		char* p = reinterpret_cast<char*>(std::malloc(sizeof(char)*10));
		// mallocはvoid*を返すのでC++だとキャストが必要なの。
		//
		// C言語では不要だけど、2つの理由でキャストされる場合があります。
		// 1. 大昔のmallocは、void*がなかったので cahr* malloc(int size)ってなっていて、char*から必要な型にキャストした時代があった
		// 2. mallocに渡すサイズを間違えていた場合、キャストしているとコンパイラが警告を出してくれるから
		//    C言語でいうとこんな感じ char *p = (int*)malloc(sizeof(int));
		//
		// 2.は確かに有効な手段かもしれません。が、がですよ、大抵 char *p = (char*)malloc(sizeof(char));と
		// いう書き方になっているんですよ(これだと警告出ません)。
		// このことから1.の延長じゃないかなと思うわけ。
		// ・・・ていうか、web上でもキャストしないと使えないという嘘情報が堂々と記載されていたりね。。。

		// んで、解放と
		std::free(p);
		p = nullptr;
		// ここでnullptrを入れるのは重複解放を防ぐためと不正アクセスですぐアプリを死亡させるため。
		// すぐ死んでくれたらスタックトレースで追跡できる可能性高い。また、ポインタがnullptrの場合freeは何もしないと
		// 規格で決まっているため、重複解放を防げる。どういうわけかこれを知らなくて
		// if (p != NULL)
		//     free(p);
		// なんてC言語を見る可能性は否定しない(が、まったく意味ない。pがNULLならそもそもfreeは何もしないから調べる意味がない)

		// んじゃ、次はC++の動的確保のサブ？(昔はメイン？)のnewとdelete

		// これは単体の領域確保と解放。new 型(コンストラクタへの引数)って形
		// nullptrへのdeleteはfreeと同じで何もしない(これも知らない方がry)
		// あと、()なかったらデフォルトコンストラクタが呼ばれる。まれに、はまることがあるよね
		int* single = new int(2);
		*single = 10;
		delete single;
		single = nullptr;

		// 配列版
		// こっちは new 型[要素数]。コンストラクタへの引数が渡せないので、独自定義クラスにデフォルトコンストラクタってのがないと
		// 使うことが出来ない。で、deleteの方に[]が付くのが要注意([]ないとメモリリーク発生)。
		// あ、そうそうこっちはコンストラクタ呼べないから、デフォルトコンストラクタがきちんと初期化してないと不定値になるからね。
		// ↓のでもmulti[3] = 1のところまでmultiの領域は全て不定値になるから。
		// そんでVSのdebug版だと直ぐクラッシュしてくれるように全部0xcdで領域を埋め尽くすけど、release版だと不定。
		// んだもんでrelease版でだけテストするとバグが見つけにくいことがある
		int* multi = new int[5];
		multi[3] = 1;
		delete[] multi;
		multi = nullptr;

		// それとVC6のせいで勘違いしてる人がたまにいらっしゃるので注意ね。
		// newが失敗した場合(まぁまずないけどね)、nullポインタが戻ってくるわけじゃないです。
		// std::bad_allocの例外(例外だってメモリ確保が必要です。だから組み込み向けのC++では例外がないことあります)がthrowされます。
		// が、newが失敗するのは、OSが逝かれているか、尋常じゃないメモリを一度に確保したか、チマチマと信じられないような領域を確保
		// する位なので単発で書くnewでも例外を捕捉しろってのはやりすぎじゃね？と個人的には思う
		// そんな人はC#やJavaでnewが失敗することを想定してコーディングしろって叫ぶのだろうか？大体実際に失敗したとして、
		// メモリが足りないからスワップが走りまくって応答がほとんど止まっているかのような状態でも動き続けるプログラムが必要
		// って状況そんなにあるんだろうかねぇ。。。
		// ※ つかJavaはわからんがC#でメモリ枯渇すると、アプリ画面が白背景、赤線のバツ印で落ちちゃうけどね(見たことある)
	}
#pragma endregion (嫌だけど)動的確保
}
