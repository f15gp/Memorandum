/**
**********************************************************************
* @file		CpluplusSample.cpp
* @brief	浅くC++言語 を学ぶためのmain
* @date		2020/08/11
* @par		Copyright
  (c) 2019-2020 Bunya
**********************************************************************
*	@par	History
*			- 2019-10-23 Bunya
*				-# 新規作成
*			- 2020-06-10 Bunya
*				-# 不適切な箇所を修正
*			- 2020-08-11 Bunya
*				-# 内容を修正
*
**********************************************************************
*/

// C++ 6日で業務コードいじれます(Lv5想定)のmain...いや、無理やろｗ
// 原則：処理はmain以外のcppファイル、hファイルに記述.
//      したがって、このmainでは大した内容を書かない予定
// 命名規則：原則スネーク記法。
//         何故かっていうとC++の標準ライブラリが大体そうだから。
//         ただし、世の中の多くはパスカル記法なのではと思う。
// 注意: C++03は原則考えない。C++11/14/17での書き方で記載予定。
//      よってC++03をいじる場合はもう少し幅広く覚えないと厳しいかも。
//      ただし、C言語との差異やC++03についても書くべき所は記載。
//      いまさら保守であってもC++03縛りにするのはいかがなものかなと思うが現実は・・・

// 断り：本プログラムはVisual Studio(以後VSと記載)にべったり依存します。このソースはVS2019でビルドされています。
//      #pragma once, #pragma region～endregion(ソースコードの任意箇所での折り畳み/展開が可能),///でのXMLドキュメントなど

// 環境: GitHubにあげるため、UTF-8(BOMなし)で書いてます(Shift-JISだと文字化けしちゃうから)。
//      しかし、VSで新規作成した場合はShift-JISで作成されるので文字コードを後から変更しています。
//      更にUTF-8ではビルドエラーになるので、プロパティ -> C/C++ -> コマンドライン "追加のオプション(D)"
//      に/source-charset:utf-8 を指定。ついでに関係ないけど、全般の文字セットも"Unicode 文字セットを使用する"に変更します。
//      しかし、ワイド文字列は扱わないので、ロケールの指定なぞはしません。
//      あと、知らない人がいるので書きますが、プロパティで指定しない限り、.cppはC++、.cはC言語としてビルドされます。

// 注意：正直、Lv5じゃねぇだろ的な話も扱うかもしれない。しかし大目に見てくれ。
//      初学者のために、あえて不正確なことを書く(だってマジメに説明するには沢山かかないといけないし)場合がある。
//      が、多分そんなに外れたことは書いてないと思う。ただし、自分が不正確に覚えてる項目はすまんこって。
//      そんでもって業務ソースはかなりC言語交じりが多い。C++をbetter Cとして使うアプローチ自体は否定しないが、
//      そのせいでC++では、どうでもいいことまで書く羽目になってる。
//      ※今のC++は既にC言語の上位互換とは言えない部分があるので、better Cとして使うにしても勉強が必要です

/************************** コメント ***************************/
// 既に多数行書いていますが、//で行末までコメントです。
// また /* ～ */で複数行コメントとなります。

/************************** インクルード ***************************/
// ↓は#includeを用いてヘッダファイルを取り込んでいます
//
// #includeは正式にはプリプロセッサというものの一部でコンパイルが始まる前に動作します。
// #includeの動作は対象ヘッダファイルを丸ごとcppファイルに"文字列"として挿入します。
//
// ヘッダファイルが何かというと、多くは後で説明する定数とか関数プロトタイプがズラズラ書かれてます。
// クラスの宣言、テンプレートも書かれたりします。
// そして、その定数などを使いたいがためヘッダファイルを取り込みます。
//
// C++は文字の入出力などの基本的な機能も標準ライブラリに丸投げし、言語機能としては持っていません。
// 何か機能が使いたいと思った時、該当するヘッダファイルをincludeしないとコンパイラが大抵エラーを出してきます。
// なぜなら、xxxという機能を使いたいとするとコンパイラはこのxxxがどういった引数などを持っているか分からないので、
// このxxxとはなんじゃい？教えてくんしゃいとエラーになるわけです。
//
// じゃぁなぜ、JavaやC#と違ってヘッダファイルというのを分けるのか？importとかじゃダメなのか？と言いますと、
// C言語が昔に作られ色々な意味でコンパイラが手を抜いているからシワ寄せで分けるのがお作法になってます。
// まぁコンパイラが手を抜いているというよりリンカというJavaなんかにはない存在に起因することが多いですが。
// ※C++はC言語を踏襲。ただし、無理が出てきたのでC++20ではモジュールが提案されている
//
// だったら、ソースファイルを取り込めば？と思う場合があるでしょうが、これは無理です。
// (出来ないという意味ではないし実際やってる例も知っているが、初心者が覚えることじゃない！)
//
// 2つ以上の異なるソースファイルから別のソースファイルをincludeすると、
// 文字列で挿入している関係で関数の実体が複数あることになったりして、ビルドエラーが多発します。
// 文字列でそのまま挿入しているため様々な問題が出ます。
//
// ちなみに、あまり見かけませんが、本来ヘッダファイルは対象のファイルが読み込むだけのプライベートなヘッダと
// 外部に公開するパブリックなヘッダが分離されるべきです。カプセル化にもなるし、ビルド時間の短縮が出来ることもある。
// ま、ちょっとこのサンプルだと分離しません。面倒な(ry
#include <iostream>

// ちなみに#includeには#include <>と#include ""の書き方があります。
// これはどこを基準にしてヘッダファイルを探すかの違いだけなので、
// 標準ライブラリのヘッダファイルとかは<>で、自分たちで作ったヘッダファイルは""にしとけば問題ないんじゃないかと
//
// それと、C++の標準ヘッダは.hが付きません。#include <iostream>みたいな感じ(古いのだと.hついてたりするけど)
// またCの標準ヘッダはcから始まるのがお約束。#include <stdio.h>が#include <cstdio>みたいに。
// これはc標準ヘッダの定数、関数をstd::という名前空間に属させるための措置だった記憶がある。

// この後#if と #endifを多用するので軽く説明。
// #if 0～#endifはその区間は無効、#if 1～#endifはその区間が有効ということ。
// #if, #elif, #else, #endifを駆使して色々やることがマレにある。
// これらも全てプリプロセッサなのでコンパイル前に文字列置き換えを色々やります。
// この#if 0で変更箇所を残していくスタイルがたまにあります。読みづらくてしょうがないですが、その時はあきらめましょう。

// あぁ、そうそうC++では各ヘッダ、ソースファイルの最後が改行で終わらないといけません。
// じゃないと未定義動作です。まぁ、たいてい問題になることはないのですが、規格的にはそうです。
// 典型的な間違いは、↓な感じ
// int main(int argc, char *argv[])
// {
//     return 0;
// }EOF
//
// 規格にはこんな感じで書かれています。
// "空でないソースファイルが改行文字で終わっていない場合、その動作は未定義とする。
//  空でないソースファイルが逆斜線に続く改行文字で終わっている場合、その動作は未定義とする。"
// ただ、C++17ではこの内容に変更が入ったという情報もありますが、確認してないのでわかりませんｗ
#include "Sample0-Global.h"
#include "Sample1-1.h"
#include "Sample2-1.h"
#include "Sample3-1.h"
#include "Sample4-1.h"

/// <summary>
/// いわゆるスタートルーチン(プログラムを起動した時、最初に呼び出される場所)です。
/// ちなみに、VSはint main()で作成する。
/// C++ 規格書に書かれているから無難な宣言は
/// int main(), int main(int argc, char** argv), int main(int argc, char* argv[])のいづれか。
/// そして、現代のコンパイラでは戻り値がvoidではエラー。でも、サンプルとかは未だにvoid main(void)なんて書いていたりする。
/// </summary>
/// <param name="argc">プログラム起動時の引数個数</param>
/// <param name="argv">プログラム起動時の引数値が入ったポインタの配列</param>
/// <returns>プログラムの終了状態 0 正常終了 0以外 異常終了</returns>
int main(int argc, char* argv[])
{
#pragma region 1日目
#if 1
	{
		// ::だけを付けるかあるいは省略するとグローバル名前空間に
		int a = ::loop_max;
	}
#endif
#pragma endregion 1日目

#pragma region 2日目
#if 1
	sample1_1::func1();
	sample1_1::func2();
	int b = sample1_1::func3(5);

	int c = 20;
	sample1_1::func4(c);
	sample1_1::func5(c);
	sample1_1::func6(&c);	// ポインタ渡しは変数に&を付ける
	sample1_1::func7(c);

	sample1_1::func8();
	sample1_1::func9();
#endif
#pragma endregion 2日目

#pragma region 3日目
#if 1
	sample2_1::func1();
	sample2_1::func2();
	sample2_1::func3();
	sample2_1::func4();
	sample2_1::func5();
	sample2_1::func6();
	sample2_1::func7();
	sample2_1::func8();
#endif
#pragma endregion 3日目

#pragma region 4日目
#if 1
	sample3_1::func1();
	sample3_1::func2();
	sample3_1::func3();
	sample3_1::func4(100);
	sample3_1::func5();
	sample3_1::func6();
	sample3_1::func7();
	std::cout << sample3_1::func8(10, 20) << std::endl;
#endif
#pragma endregion 4日目

#pragma region 5日目
#if 1
	sample4_1::func1();
#endif
#pragma endregion 5日目

#pragma region 6日目
#if 1
	// 初期化について補足しておく
	// 凄まじく複雑なのでかなり簡略化してる
	int x;		// ローカル変数なので初期化されない。後で確実に代入されるパスがないなら、絶対に初期化すること
	x = 1;		// 意味ないけど警告対策措置

	// ゼロ初期化
	int i{};	// 0になる
	double d{};	// 0.0となる
	int* ptr{};	// nullptr
	int int_array1[5] = { 1, 2, 3 };	// [0]から[2]は1,2,3で初期化。[3]と[4]はゼロ初期化により0

	// 値初期化
	class hoge_class {
	private:
		int _m;
	};
	hoge_class hc{};	// デフォルトコンストラクタが呼び出されるが、↑だとコンストラクタがないのでゼロ初期化される
	int int_array2[3]{};	// 配列で要素はスカラなので3つの領域全てが0に初期化される

	// コピー初期化(これはコピーコンストラクタが呼ばれる初期化)
	int ih = 5;	// 組み込み型なのであれだが、実際にはコピーコンストラクタを呼び出すのと同義。
				// 簡単に言うと = で初期化されるものは全てこのコピー初期化扱い(他にも色々あるんだけどさ)
				// だから、そんなときにコピーコンストラクタをdeleteしてるとコンパイルエラーになりますんでお気を付けを

	// ま、上記のことと歴史的経緯を含めて、
	// こうしとけばいんじゃない？
	int ii = 0;	// コピー初期化となるけど、組み込み型は全部これ
	int int_array3[10] = { 0 };	// 配列はC言語あがりにも考慮したもの。ゼロ初期化
	hoge_class hc2{};			// オブジェクトは値初期化。
								// でも、 全てのメンバ変数は明示的に値を初期化orコンストラクタor初期化リストで設定してね
	std::vector<int> vec1{ 1,2,3,4 };	// コンテナは全部統一初期化で

	// 一時オブジェクトで使う()の初期化とかもあるけど、()での初期化は説明が難しいしPODが絡むので省略する。
	// 気になったら各自でよろしく
#endif
#pragma endregion 6日目

	return 0;
}
