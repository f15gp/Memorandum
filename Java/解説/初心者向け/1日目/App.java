/**
 * Javaの勉強 1日目(メソッド、引数、制御構文(if, switch, for))
 * 
 * @version 1.0.0
 * @author Bunya
 */

// Java 5日である程度モダン？なJavaが書けるようになります(Lv5想定)
// はじめに：巷にあふれる入門書は入門で終わってることが多いので、
//         もう少し仕組みがちょっとだけ深く理解ができるような資料になることを目指してみました。
//         しかし、筆者の備忘録も兼ねているため、多少(ほとんど？)入門的な内容も書いてます。
//
// 命名規則：原則、クラスはパスカル記法、メソッド、変数はキャメル記法。
//         他も多分一般的な"Javaでの"規則を採用してるかと。
//         ※ メソッド開始{の位置は、メジャーな言語で恐らくJava & Javascriptだけが採用する同じ行に書くスタイル。
//
// 注意: 筆者はJavaの素人です。初心者です。
//      トンチンカンなことを書いてる場合があるかもしれませんが、そこはまぁご愛嬌で。
//
//      そして、Javaが好きではないです。最低な言語とかではないですが、好きではないです。
//      なので、書き方にそれが表れているかもしれません。
//      良いところもたくさんありますが、根底に流れる思想などが苦手なだけです。ご了解を。
//
//      また、Java 11をメインに17程度までの内容で記載すると思いますが、詳しく調べてるわけでは
//      ないので、使えれるようになるバージョンを間違えているかもしれません。
//
// 環境: ラズパイ上で動作確認しているため、UTF-8(BOMなし) 行末:LFで書いてます。
//      バージョンは、Openjdk 11.0.23 2024-04-16です。
//      エディタでソースを書いて、コマンドで実行する一番基本のやり方を行っています。
//      デバッガも付属のjdbを使ってます。
//      なお、環境の構築方法は各人でやってください。
//
//      また通常はjavacコマンドによる中間コードへのコンパイルとjavaコマンドによるJVMへの.classファイルロードによって
//      実行しますが、パッケージというものを使用していないときはjava *.javaでも実行できます。
//      ※ javaコマンドによるコンパイルなしの実行はJava 11から。
//        まぁ、多くの人はeclipseとかで実行してるでしょうから、今どきコマンドラインなんか使わないかもしれませんけどね。

/************************** コメント ***************************/
// 既に多数行書いていますが、//で行末までコメントです。
// また /* ～ */で複数行コメントとなります。

/**
 * アプリ クラス
 * 
 * これはJavadocというのものでクラスやメソッドの内容を書いていくものです。<br>
 * javadocコマンドを使用するとHTMLのドキュメントが生成できます。<br>
 * クラスとはなにか？これについては後ほど書きます。
 */
public class App {

    /**
     * Mainメソッド<br>
     * アプリに一つは存在しないといけないメソッド。<br>
     * メソッドとはなにか？これについては後ほど書きます。
     * publicやstaticも後ほど・・・<br>
     * ちなみに@paramと@returnを書いたり書かなかったりするのは、<br>
     * 戻り値がないまたは引数がない場合に書いてしまうとjavadocでhtmlを作成するときに警告されるから。
     * 
     * @param args 起動時に与えられたコマンドの配列
     */ 
    public static void main(String[] args) {
        // メソッドの呼び出し
        first(1);
        second();
        third();
        fourth();
        fifth();

        // 画面に表示する
        System.out.println("正常終了");
    }

    /**
     * 最初のメソッド(説明用)
     * 
     * @param arg 引数
     * @return 処理結果(このメソッドではtrueのみ返す)
     */
    static boolean first(int arg) {
        // メソッド
        // メソッドは一つの処理を書くものです。(複数の機能を担うことも出来ますが、基本は単一機能)
        // 基本は引数でデータを与えて、戻り値で結果を返すことです。
        // 書式は、"戻り値 メソッド名(引数の型 仮引数名)"になります。
        // ※ もちろん引数がない。戻り値がないメソッドもありえます。

        // 変数の型 一覧
        // 変数は、基本データ型(プリミティブ)と参照型に大別されます。
        
        // 基本データ型(プリミティブ)
        // 論理値
        boolean	b1 = true; // trueかfalseが入る
        // 文字
        char c1 = 'あ'; // 16ビット 符号なし Unicode UTF-16 コードユニット
        // 整数
        byte by1 = 1; // 8ビット 符号付き 2の補数表現の整数
        short s1 = 1; // 16ビット 符号付き 2の補数表現の整数
        int i1 = 1; // 32ビット 符号付き 2の補数表現の整数
        long l1 = 1L; // 64ビット 符号付き 2の補数表現の整数
        // 浮動小数点数
        float f1 = 1.0f; // 32ビット IEEE754 浮動小数点数
        double d1 = 1.0; // 64ビット IEEE754 浮動小数点数

        // 参照型
        // クラス、インターフェース、配列が該当。
        // ※ 多分charより馴染み深く文字列を扱う場合は、Stringクラスを
        //   利用していると思うので、Stringも参照型になります。

        // なお、これとは別にラッパークラス(クラスなので参照型)があります。
        // なんすかそれ？と言われると、BooleanとかIntegerのことです。
        //
        // 簡単にいうとプリミティブをオブジェクトとして扱うためのものです。
        // ？と思った人いるでしょうが、プリミティブはただのデータなので、
        // メソッドを使ったデータ処理ができません。例えば次のようなことをしたい場合です。
        int i2 = Integer.parseInt("16");

        // これにちなんでオートボクシングとアンボクシングという言葉を目にしたことが
        // あるかもしれません。
        // そいつらは単純に、
        // オートボクシング: プリミティブ型からラッパークラスへの変換
        // アンボクシング: ラッパークラスからプリミティブ型への変換
        // です。
        int i3 = 10;
        Integer numInt = i3; // これがオートボクシング
        // もし真面目にやるなら、
        // Integer numInt = new Integer(i3);またはInteger numInt = Integer.valueOf(i3);
        // 実を言うとこの機能は、Java 1.0に存在せずJava 5.0で追加された文法。

        // リテラルについては省略

        return true;
    }

    /**
     * 2つ目のメソッド(説明用)
     * 
     */
    static void second() {
        // メソッド説明 続き
        // 戻り値がない場合は、戻り値のところにvoidと書く。
        // 引数がない場合は、引数のところをvoidでなく空っぽにする。

        // ここでは参照型を説明。
        // 参照型はプリミティブと違い、使うにはnewをしなければいけません。
        // ※ 宣言だけも出来ますが、newせずに使うとNullPointerExceptionという有名な例外が発生します。例外もまたあとで。
        String s1; // こっちは宣言だけなので、使う前にnewを行う必要がある。
        String s2 = new String("あいうえお");

        // ここでふと疑問に思った人がいるとは思います。
        // "いつもStringを定義するとき、newなんてしてないぞ"と
        // そう、普通はこういう風にしますよね？
        String s3 = "あいうえお";
        // はい。そのとおりです。実はStringは特別にnewしなくても使えるようになってます。
        // 何が違うかと言うと String Constant Pool(もしくはString Constant Memory Pool)に格納するかどうかが変わってきます。
        // ？？何だ、それ？？と思う方いるでしょうが、Javaの1.0から備わってます。
        //
        // 恐らく、Java誕生当時の時代背景があったと思うのですが、メモリを節約して(で、ついでに高速化)を
        // するためのものです。細かい話はネットで探してもらえばいいのですが、
        String s4 = "Test"; // 初回なのでメモリ領域を確保してConstant Poolに入れる
        String s5 = "Test"; // Constant Poolにすでに存在するので参照先を結びつける(=s4とs5は同じデータを指す)
        // という感じになります。
        // Stringが不変オブジェクトなのは、この仕組みにあります。全て共有してるので、
        // 勝手に書き換えるわけにはいかないからです。
        // 不変オブジェクト(イミュータブル)は、簡単に言うと書き換え不能オブジェクト。

        // ちなみに、サラッと上で参照先を結びつけるなんて書きましたが、
        // 参照型はその名前の通り、newされたインスタンスがメモリ上に確保した領域を参照する型になります。
        // そのため、参照型においての代入は参照先の書き換えを意味します。
        // ※ String(newしない時)は先程のConstant Poolがあるので、書き換えになる場合と新しい領域を作る場合に別れます。

        // 絵で書いた方がわかりやすいのですが、頑張って書いてみます。
        // 実行すると違いがわかるかなと。
        // プリミティブ
        int i1 = 1;
        int i2 = i1;
        i2 = 2;
        System.out.println(i1); // 1
        System.out.println(i2); // 2

        // 参照型の一つ 配列
        char[] array1 = {'A', 'B', 'C', 'D'};
        char[] array2 = array1;
        array2[0] = 'F';
        System.out.println(array1); // FBCD
        System.out.println(array2); // FBCD
        // 配列は最初の頃、以下のどちかの形でしか宣言出来なかった記憶がある。
        // char[] p = new int[10];
        // char p[] = new int[10]; <- こちらは恐らくC言語の人間に配慮したと思う。
        // しかし、今は char[] 変数 = {};の形で用意出来るようになっているようだ。
        // 記憶違いで最初から出来たのか、あるバージョンから出来るようになったのか？これは正直わからない。
        // ちなみに、以下のように最後の,は無視されるので書いても問題はない。
        // char[] p = { 'A', 'B', };
        // ただ、配列のりサイズは出来ないので、今は確実にサイズが決まってない限り、配列でなくコレクションを使用すると思う。

        // 文字列(これも参照型)
        String s6 = "文字列";
        String s7 = s6;
        s7 = "モジレツ";
        System.out.println(s6); // 文字列
        System.out.println(s7); // モジレツ

        // 参照型をメソッドの引数として渡す場合、代入が発生して参照先のコピーが渡される。
        // そのため、メソッド内での変更が呼び出し元の変数に影響する場合がある。
        char[] array3 = {'A', 'B', 'C'};
        changeArray(array3);
        System.out.println(array3); // GBC
        String s8 = "実験";
        changeString(s8);
        System.out.println(s8); // 実験
    }

    /**
     * Arrayを書き換えてみる風のメソッド
     * 
     * @param array 書き換えようとしてる配列
     */
    static void changeArray(char[] array) {
        // これがプリミティブの場合なら値のコピーが渡されるだけなので変更したとしても、呼び出し元に何の影響もでません。
        // ただ、参照型の場合は参照先の値がコピーして渡されるため、変更が呼び出し元の変数にも波及します。
        array[0] = 'G';
        // クラスというものだともう少し違う動作になるので、クラスを説明した後にまた書くかもしれません。★★★

        // array = null;
        // ただし、arrayにnullを代入した場合は、実引数のarrayがnullとなるだけです。
        // nullを代入した結果として、呼び出し元変数の参照先情報が失われてしまうので、
        // この代入以降は呼び出し元の変数に対して影響を及ぼすことがなくなります。
        // ※ ただし、null入れたあとにarrayに対してnewもせずにアクセスすると当然ヌルポになります。
    }

    /**
     * Stringを書き換えてみる風のメソッド
     * 
     * @param string 書き換えようとしてる文字列
     */
    static void changeString(String string) {
        // StringはConstant Poolが関わるので、書き換えてる風に思えるが、書き換えは起きていません。
        // Contant Poolに登録されてなければ新たに登録されるし、登録されていれば参照先をそれにするだけです。
        string = "ジッケン";
        // string += "ジッケン";となっていても、
        // 結合した文字列で新たなstringを作成してConstant Poolに格納するため、
        // やはり呼び出し元のStringには影響が出ません。

        // ・・・ただ、文字列はこういった挙動となるため、ループ中の結合などを行う場合は、
        // 性能的に問題となるので、そういう場合はStringBuilderやStringBufferを使いましょう。
        // という話になる。
        // ただ、それらが使えるのも Java 5.0以降からなんですけどね(まぁ今は問題ないでしょ。こんな昔の環境)
        //
        // でも1行だけの+=などはjavacのバージョンによってStringBuilderなどに勝手に置き換えられるので、
        // わざわざStringBuilderなどを使う必要はない。
        // ※ もしかしたら将来的にはループ中も賢く置き換える可能性も0じゃない。
        //   だから、目に見えて遅いことがはっきりするまで、明示的にStringBuilderを使う必要はないかもね。
        //   Javaを使用するサーバーサイドは、基本性能を上げて(サーバーを増やすなど)対処するのが基本路線なのでね・・・

        // ちなみにC#でもヒープに確保する Poolの仕組みが文字列に対して行われますが、
        // C#の場合は引数に付与できるrefやoutにより、引数の内容を本当に書き換えることが可能となっているところが違います。

        // 追記
        // StringBuilderとかの代わりに、C#で言うSpan<T>やMemory<T>がJavaにあるのか筆者はわからない。
    }

    /**
     * 3つ目のメソッド(説明用)
     * 
     */
    static void third() {
        // 制御構文について(if)

        // if
        // ifは比較を行うときに使います。
        // if (条件式(結果がbooleanになる式)) {
        // }
        // が書式です。
        boolean b1 = false;
        if (!b1) {
            // 成立する
            System.out.println("falseです");
        }
        // ここで注意としてbooleanを==で比較する場合は、以下の==でなく=になるパターンはハマりやすいのでお気をつけを。
        // ただ最近はbooleanは !変数(==falseと同義) or 変数(==trueと同義)で記述するのが一般的かなと。
        if (b1 = false) {
            // 成立しない(b1に代入したのがfalseなので式として評価すると常にfalseとなるため)
            System.out.println("falseです");
        }

        // また、参照型を比較する場合は参照先が等しいかを比べることに注意。
        char[] array1 = {'A', 'B', 'C', 'D'};
        char[] array2 = array1;
        char[] array3 = {'A', 'B', 'C', 'D'};
        if (array1 == array2) {
            // 成立する
            System.out.println("array1 == array2です");
        }
        if (array1 == array3) {
            // 成立しない
            System.out.println("array1 == array3です");
        }

        // よって参照型の内容を比べたいときや文字列を比較したいときは
        // equals()を使います。その参照型が正しくequalsを実装してればですけど。
        // まぁStringは大文字/小文字を区別するとは言え、equalsは正しく実装されてるね。
        // ※ StringはString Constant Poolを使って==で比較することも可能だが、一般的にはequalsを使う。
        String s1 = "文字列";
        String s2 = s1;
        if (s1.equals(s2)) {
            // 成立する
            System.out.println("s1 == s2です");
        }

        // if は else if と elseというのが他にあります。
        // 下のように書きます。
        // else ifはifとは異なる条件を並べるのに使います。
        // また、elseはいずれの条件にも該当しない場合に行う処理を記述します。
        // この書き方でわかる人はわかると思いますが、if 〜 else if 〜 elseは、条件が成立するまで
        // 一つずつ調べていく形になります。
        // ※ すごくどうでもいい話ですが、else ifはそういう文法があるわけではないです。
        //   ifに該当しないelseの続きにifを書いてるだけです。これは{を使わない場合に発生する
        //   ぶら下がりelse問題に関係してきますが、ここはC言語から変わってないし、恐らく今は
        //   たとえ可能な場合でも必ず{をつけさせるケースが多いと思うので、気にしなくて良いはず。
        int i1 = 1;
        if (i1 == 1) {
            System.out.println(i1);
        } else if (i1 == 2) {
            System.out.println(i1);
        } else {
            System.out.println(i1);
        }
    }

    /**
     * 4つ目のメソッド(説明用)
     * 
     */
    static void fourth() {
        // 制御構文について(switch)

        // switch
        // switchは一つの式に対して複数の比較を行うときに使います。
        // switch (変数など) {
        // case 1:
        //     処理;
        //     break; <-必要なら(breakをつけない場合、次のcase or defaultを実行する)
        // default: <- 必要なら(どのcaseにも該当しないときの処理)
        // }
        // が書式です。
        //
        // 知らない人がたまにいますが、caseやdefaultを置く順番は自由です。
        // ただまぁおとなしくdefaultを最後にしておけばいいかなと。
        // それにdefaultを必ず書けというルールも多いので、素直に最後においておけばと。
        int i1 = 3;
        switch (i1) {
        default: // fall through(フォールスルー)
        case 3:
            System.out.println(i1); // 3
        }

        // ネットを見ると、上のフォールスルーを知らなくて気持ち悪いからifに書き換えたのを
        // リファクタリングの例にあげていた。
        // 少しアホかなｗとは思った。
        //
        // その記事の書き換え前の例は次の通りだった。
        //switch (cmd) {
        //    case 0:
        //        // 処理A
        //        // fall through
        //    case 1:
        //    case 2:
        //        // 処理B
        //        break;
        //    default:
        //        // 処理C
        //        break;
        //}
        // そりゃこれをリファクタリングするのはいいけど、ifに書き換えるかね？
        // ※ おまけにそのifは2024/11/10時点で処理Aのみ実行するものになっていてデグレしてるし。
        //
        // それに、このfall throughのコメントの入れ方は一般的じゃない。
        // せめて書き換えるなら、switchのままで、このように変えるんじゃねぇのかと？
        //switch (cmd) {
        //case 0:
        //    // 処理A
        //    // 処理B
        //    break;
        //case 1: // fall through
        //case 2:
        //    // 処理B
        //    break;
        //default:
        //    // 処理C
        //    break;
        //}
        // どちらにせよ自分が知らないからとかそういう理由で書き換える発想をするのは、あまり良くない。
        // というか場合によっては怒られるはず。まだまだリファクタリングに寛容じゃない現場は多い。

        // ところで Java7からはswitchでStringを扱うことが出来るようになりました。
        // そのため switchで扱えるのはint, short, char, byte, enum, Stringになります。
        // また、Stringの場合内部的にequalsと同じ処理が行われているので 大文字/小文字が区別されます。
        String color = "青色";
        switch (color) {
        case "赤色":
            System.out.println(color + ":" + "トマトの色");
            break;
        case "青色":
            System.out.println(color + ":" + "空の色"); // 青色:空の色
            break;
        default:
            break;
        }
        // ちなみにcaseに同じ値が指定されるとコンパイルエラーとなるので、
        // 文字列をだらだらと比較する場合はifよりswitchを使うべきだと思います。
        // if 〜 else ifのequals連発だとうっかり比較文字列が重複してもコンパイルエラーにならないから。

        // enumやパターンハッチングはクラスを説明した後でないと厳しいので、多分後で書く ★★★
    }

    /**
     * 5つ目のメソッド(説明用)
     * 
     */
    static void fifth() {
        // 制御構文について(for)

        // for
        // forは処理を繰り返し行う場合に使います。
        // for (初期化式; ループ式; 更新式)
        //     statement
        // が書式です。
        // ただ、恐らくどの現場でもブレース({})で囲めという形になると思います。

        // また、現在この基本形でforを使うことは稀になってきていると思います。
        // 拡張for文、Stream(これは後で (ry)があるからです。★★★
        int[] array = { 1, 2, 3, 4 };
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
        // 拡張for文ならこう
        for (int a : array) {
            System.out.println(a);
        }
        // 配列でなくArrayListなどを使う場合も原則拡張for文を使う。
        // 基本形を使うとなるとループさせる配列の中身を書き換えたい。などの場合でしょうか？
        // ただし、中身を書き換えるようなケースはほとんどの場合Streamを使う方がいい。
        // 特定の回数だけ回す用途でもrangeで行えばいいので基本形はほぼ不要となっている。

        // label付きのbreakとか(continueもあるけど無視)
        // 普通breakはforの場合、内側のループからのみ脱出できます。
        // ところが以下のように外側のforに"jumpLabel"というラベルをつけて、
        // breakでラベルを指定すると、指定ラベルのforの外に出ていきます。
        jumpLabel:for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.println("break");
                break jumpLabel;
            }
        }
        // ちなみにこのラベル付きbreakとcontinueは、gotoを使わないために生み出された文法です。
        // ※ これは gotoの使用方の一つである多重ループからの脱出の代替です。
        //
        // でも、これ巷にあるグローバル変数というのと同じで呼び方が違うだけでgotoにしか見えないのですがねぇ・・・
        // 正直、C言語でもgotoのラベルをgotoより前方に書くのは"スパゲッティコード"になりかねないのでご法度なのですが、
        // このラベルをつけるにはbreakより前方に書く必要があるので余計嫌なんですよね。
        // まぁ多重ループを書いてかつ一気に抜ける必要がある場合には使えるのでその時にでも使ってください。
        // ※ ちなみに実はグローバル変数という文法はC言語とかに存在しないので、変数の使い方を示す言葉なんですが、
        //   どうもネットなどでは誤解してる気がしてならない。

        // whileやdo-whileは無視。whileは基本forでまかなえるし、do-whileは一旦アルゴリズムが正しいか？
        // を確認してから使う位、レアなものだから。

        // var(ローカル変数の型推論)
        // Java 10 からローカル変数を推論してくれる機能です。
        // 先程の拡張forは原則varを使った方がいいでしょう。使わないメリットが思いつかない。
        for (var a : array) {
            // System.out.println(a);
        }
        // varはコーディング規則に縛られると思うが、右辺が明確な場合に使えばいいと思う。
        var list = new java.util.ArrayList<String>(); // new してるので型が明確
        var s = "hoge"; // 右辺が文字列なのは明白
        var date = java.time.LocalDateTime.now(); // 戻り値で型が明確なので明白

        // finalとかstaticはクラスに入ってから ★★★
    }

}
