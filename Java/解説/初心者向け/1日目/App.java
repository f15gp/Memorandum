/**
 * Javaの勉強 1日目
 * 
 * @version 1.0.0
 * @author 文箭
 */

// Java 5日である程度モダン？なJavaが書けるようになります(Lv5想定)
// はじめに：巷にあふれる入門書は入門で終わってることが多いので、
//         もう少し仕組みがちょっとだけ深く理解ができるような資料になることを目指してみました。
//         しかし、筆者の備忘録も兼ねているため、多少(ほとんど？)入門的な内容も書いてます。
//
// 命名規則：原則、クラスはパスカル記法、メソッド、変数はキャメル記法。
//         他も多分一般的な"Javaでの"規則を採用してるかと。
//         また{の位置は、メジャーな言語で恐らくJavaだけが採用する同じ行に書くスタイル。
//
// 注意: 筆者はJavaの素人です。初心者です。
//      トンチンカンなことを書いてる場合があるかもしれませんが、そこはまぁご愛嬌で。
//
//      そして、Javaを嫌いです。最低な言語とかではないですが、嫌いです。
//      なので、書き方に嫌な気持ちが溢れているかもしれません。
//      良いところもたくさんありますが、根底に流れる思想が嫌いなだけです。ご了解を。
//
//      また、Java 11をメインに17程度までの内容で記載すると思いますが、詳しく調べてるわけでは
//      ないので、使えれるようになるバージョンを間違えているかもしれません。
//
// 環境: ラズパイ上で動作確認しているため、UTF-8(BOMなし) 行末:LFで書いてます。
//      バージョンは、Openjdk 11.0.23 2024-04-16です。
//      エディタでソースを書いて、コマンドで実行する一番基本のやり方を行っています。
//      デバッガも付属のjdbを使ってます。
//      なお、環境の構築方法は各人でやってください。
//
//      また通常はjavacコマンドによる中間コードへのコンパイルとjavaコマンドによるJVMへの.classファイルロードによって
//      実行しますが、パッケージというものを使用していないときはjava *.javaでも実行できます。
//      ※ javaコマンドによるコンパイルなしの実行はJava 11から。
//        また、多くの人はeclipseとかで実行してるでしょうから、今どきコマンドラインなんか使わないかもしれませんけどね。

/************************** コメント ***************************/
// 既に多数行書いていますが、//で行末までコメントです。
// また /* ～ */で複数行コメントとなります。

/**
 * アプリ クラス
 * 
 * これはJavadocというのものでクラスやメソッドの内容を書いていくものです。<br>
 * javadocコマンドを使用するとHTMLのドキュメントが生成できます。<br>
 * クラスとはなにか？後ほど書きます。
 */
public class App {

    /**
     * Mainメソッド<br>
     * アプリに一つは存在しないといけないメソッド。<br>
     * メソッドとはなにか？後ほど書きます。
     * publicやstaticも後ほど・・・
     * 
     * @param args 起動時に与えられたコマンドの配列
     */ 
    public static void main(String[] args) {
        // メソッドの呼び出し
        first(1);
        second();
        third();
        fourth();

        // 画面に表示する
        System.out.println("正常終了");
    }

    /**
     * 最初のメソッド(説明用)
     * 
     * @param arg 引数
     * @return 処理結果(このメソッドではtrueのみ返す)
     */
    static boolean first(int arg) {
        // メソッド
        // メソッドは一つの処理を書くものです。(複数の機能を担うことも出来ますが、基本は単一機能)
        // 基本は引数でデータを与えて、戻り値で結果を返すことです。
        // 書式は、"戻り値 メソッド名(引数の型 仮引数名)"になります。
        // ※ もちろん引数がない。戻り値がないメソッドもありえます。

        // 変数の型 一覧
        // 変数は、基本データ型(プリミティブ)と参照型に大別されます。
        
        // 基本データ型(プリミティブ)
        // 論理値
        boolean	b1 = true; // trueかfalseが入る
        // 文字
        char c1 = 'あ'; // 16ビット 符号なし Unicode UTF-16 コードユニット
        // 整数
        byte by1 = 1; // 8ビット 符号付き 2の補数表現の整数
        short s1 = 1; // 16ビット 符号付き 2の補数表現の整数
        int	i1 = 1; // 32ビット 符号付き 2の補数表現の整数
        long l1 = 1L; // 64ビット 符号付き 2の補数表現の整数
        // 浮動小数点数
        float f1 = 1.0f; // 32ビット IEEE754 浮動小数点数
        double d1 = 1.0; // 64ビット IEEE754 浮動小数点数

        // 参照型
        // クラス、インターフェース、配列が該当。
        // ※ 多分charより馴染み深く文字列を扱う場合は、Stringクラスを
        //   利用していると思うので、Stringも参照型になります。

        // なお、これとは別にラッパークラス(クラスなので参照型)があります。
        // なんすかそれ？と言われると、BooleanとかIntegerのことです。
        //
        // 簡単にいうとプリミティブをオブジェクトとして扱うためのものです。
        // ？と思った人いるでしょうが、プリミティブはただのデータなので、
        // メソッドを使ったデータ処理ができません。例えば次のようなことをしたい場合です。
        int i2 = Integer.parseInt("16");

        // これにちなんでオートボクシングとアンボクシングという言葉を目にしたことが
        // あるかもしれません。
        // そいつらは単純に、
        // オートボクシング: プリミティブ型からラッパークラスへの変換
        // アンボクシング: ラッパークラスからプリミティブ型への変換
        // です。
        int i3 = 10;
        Integer numInt = i3; // これがオートボクシング
        // もし真面目にやるなら、
        // Integer numInt = new Integer(i3);またはInteger numInt = Integer.valueOf(i3);
        // 実を言うとこの機能は、Java 1.0に存在せずJava 5.0で追加された文法。

        return true;
    }

    /**
     * 2つ目のメソッド(説明用)
     * 
     */
    static void second() {
        // メソッド説明 続き
        // 戻り値がない場合は、voidをつける。
        // 引数がない場合は、voidでなく空っぽにする。

        // ここでは参照型を説明。
        // 参照型はプリミティブと違い、使うにはnewをしなければいけません。
        // ※ 宣言だけも出来ますが、newせずに使うとNullPointerExceptionという有名な例外が発生します。例外もまたあとで。
        String S1; // こっちは宣言だけなので、使う前にnewを行う必要がある。
        String s2 = new String("あいうえお");

        // ここでふと疑問に思った人がいるとは思います。
        // "いつもStringを定義するとき、newなんてしてないぞ"と
        // そう、普通はこういう風にしますよね？
        String s3 = "あいうえお";
        // はい。そのとおりです。実はStringは特別にnewしなくても使えるようになってます。
        // 何が違うかと言うと String Constant Pool(もしくはString Constant Memory Pool)に格納するかどうかが変わってきます。
        // ？？何だ、それ？？と思う方いるでしょうが、Javaの1.0から備わってます。
        //
        // 恐らく、Java誕生当時の時代背景があったと思うのですが、メモリを節約して(で、ついでに高速化)を
        // するためのものです。細かい話はネットで探してもらえばいいのですが、
        String s4 = "Test"; // 初回なのでメモリ領域を確保してConstant Poolに入れる
        String s5 = "Test"; // Constant Poolにすでに存在するので参照先を結びつける
        // という感じになります。
        // Stringが不変オブジェクトなのは、この仕組みにあります。全て共有してるので、
        // 勝手に書き換えるわけにはいかないからです。
        // 不変オブジェクト(イミュータブル)は、簡単に言うと書き換え不能オブジェクト。

        // ちなみに、サラッと上で参照先を結びつけるなんて書きましたが、
        // 参照型はその名前の通りオブジェクトがメモリ上に確保した領域を参照する型になります。
        // そのため、参照型においての代入は参照先の書き換えを意味します。
        // ※ String(newしない時)は先程のConstant Poolがあるので、書き換えになる場合と新しい領域を作る場合に別れます。

        // 絵で書いた方がわかりやすいのですが、頑張って書いてみます。
        // 実行すると違いがわかるかなと。
        // プリミティブ
        int i1 = 1;
        int i2 = i1;
        i2 = 2;
        System.out.println(i1); // 1
        System.out.println(i2); // 2

        // 参照型
        char[] array1 = {'A', 'B', 'C', 'D'};
        char[] array2 = array1;
        array2[0] = 'F';
        System.out.println(array1); // FBCD
        System.out.println(array2); // FBCD

        // 文字列
        String s6 = "文字列";
        String s7 = s6;
        s7 = "モジレツ";
        System.out.println(s6); // 文字列
        System.out.println(s7); // モジレツ

        // 参照型をメソッドの引数として渡す場合、代入が発生して参照先のコピーが渡される。
        // そのためメソッド内での変更が呼び出し元の変数に影響する場合がある。
        char[] array3 = {'A', 'B', 'C'};
        changeArray(array3);
        System.out.println(array3); // GBC
        String s8 = "実験";
        changeString(s8);
        System.out.println(s8); // 実験
    }

    /**
     * Arrayを書き換えてみる風のメソッド
     * 
     * @param array 書き換えようとしてる配列
     */
    static void changeArray(char[] array) {
        // これがプリミティブの場合なら値のコピーが渡されるだけなので何も影響がでない。
        // ただ、参照型の場合は参照先の値がコピーして渡されるため、変更が呼び出し元の変数にも波及する。
        array[0] = 'G';

        // array = null;
        // ただし、arrayにnullを代入した場合はarrayがnullとなるだけです。
        // 結果として、参照先の情報は失われてしまうので、呼び出し元の変数に影響がでなくなります。
    }

    /**
     * Stringを書き換えてみる風のメソッド
     * 
     * @param string 書き換えようとしてる文字列
     */
    static void changeString(String string) {
        // StringはConstant Poolが関わるので、書き換えてる風に思えるが、事実は違う。
        string = "ジッケン";
        // これにはStringが不変オブジェクトなのも関係しています。
        // 例えば string += "ジッケン";となっていても、
        // 新たな文字列が作成されて格納されるだけで呼び出し元には影響が出ません。
        //
        // ★★★ これはここで書くべきか？
        // ・・・ただ、これがあるが故、ループなどで文字列の加工を行う場合は、毎回stringが生成されて
        // 問題となるので、StringBuilderやStringBufferを使いましょう。
        // という話になるのよ。
        // ただ、それらが使えるのも Java 5.0以降からなんですけどね(まぁ今は問題ないでしょ。こんな昔の環境)

        // ちなみにC#でもヒープに確保する Poolの仕組みが文字列に対して行われますが、
        // C#の場合はrefやoutにより、引数の内容を本当に書き換えることが可能となっているところが違います。

        // 追記
        // StringBuilderとかの代わりに、C#で言うSpan<T>やMemory<T>がJavaにあるのか筆者はわからない。
    }

    /**
     * 3つ目のメソッド(説明用)
     * 
     */
    static void third() {
        // 制御構文について(if)

        // if
        // ifは比較を行うときに使います。
        // if (条件式(結果がbooleanになる式)) {
        // }
        // が書式です。
        boolean b1 = false;
        if (!b1) {
            // 成立する
            System.out.println("falseです");
        }
        // ここで注意としてbooleanを==で比較する場合は、以下の==でなく=になるパターンはハマりやすいのでお気をつけを。
        // ただ最近はbooleanは !変数(==falseと同義) or 変数(==trueと同義)で記述するのが一般的かなと。
        if (b1 = false) {
            // 成立しない
            System.out.println("falseです");
        }

        // また、参照型を比較する場合は参照先が等しいかを比べることに注意。
        char[] array1 = {'A', 'B', 'C', 'D'};
        char[] array2 = array1;
        char[] array3 = {'A', 'B', 'C', 'D'};
        if (array1 == array2) {
            // 成立する
            System.out.println("array1 == array2です");
        }
        if (array1 == array3) {
            // 成立しない
            System.out.println("array1 == array3です");
        }

        // よって参照型の内容を比べたいときや文字列を比較したいときは
        // equals()を使います。その参照型が正しくequalsを実装してればですけど。
        // まぁ文字列は大文字/小文字を区別するとは言え、equalsをまともに実装してるけど。
        // ※ StringはString Constant Poolを使って==で比較することも可能だが、一般的にはequalsを使う。
        String s1 = "文字列";
        String s2 = s1;
        if (s1.equals(s2)) {
            // 成立する
            System.out.println("s1 == s2です");
        }

        // if は else if と elseというのが他にあります。
        // 下のように書きます。
        // else ifはifとは異なる条件を並べるのに使います。
        // また、elseはいずれの条件にも該当しない場合に行う処理を記述します。
        // この書き方でわかる人はわかると思いますが、if 〜 else if 〜 elseは、条件が成立するまで
        // 一つずつ調べていく形になります。
        // ※ すごくどうでもいい話ですが、else ifはそういう文法があるわけではないです。
        //   ifに該当しないelseの続きにifを書いてるだけです。これは{を使わない場合に発生する
        //   ぶら下がりelse問題に関係してきますが、ここはC言語から変わってないし、恐らく今は
        //   たとえ可能な場合でも必ず{をつけさせるケースが多いと思うので、気にしなくて良いはず。
        int i1 = 1;
        if (i1 == 1) {
            System.out.println(i1);
        } else if (i1 == 2) {
            System.out.println(i1);
        } else {
            System.out.println(i1);
        }
    }

    /**
     * 4つ目のメソッド(説明用)
     * 
     */
    static void fourth() {
        // 制御構文について(switch)

        // switch
        // switchは一つの式に対して複数の比較を行うときに使います。
        // switch (変数など) {
        // case 1:
        //     処理;
        //     break; <-必要なら(breakをつけない場合、次のcase or defaultを実行する)
        // default: <- 必要なら(どのcaseにも該当しないときの処理)
        // }
        // が書式です。
        //
        // 知らない人がたまにいますが、caseやdefaultを置く順番は自由です。
        // ただまぁおとなしくdefaultを最後にしておけばいいかなと。
        // それにdefaultを必ず書けというルールも多いので、素直に最後においておけばと。
        int i1 = 3;
        switch (i1) {
        default: // fall through(フォールスルー)
        case 3:
            System.out.println(i1); // 3
        }

        // ネットを見ると、上のフォールスルーを知らなくて気持ち悪いからifに書き換えたのを
        // リファクタリングの例にあげていた。
        // 少しアホかなｗとは思った。
        //
        // そのときの例は次の通りだった。
        //switch (cmd) {
        //    case 0:
        //        // 処理A
        //        // fall through
        //    case 1:
        //    case 2:
        //        // 処理B
        //        break;
        //    default:
        //        // 処理C
        //        break;
        //}
        // そりゃこれをリファクタリングするのはいいけど、ifに書き換えるかね？
        // ※ おまけにそのifは2024/10/12時点で処理Aのみ実行するものになっていてデグレしてるし。
        //
        // それに、このfall throughのコメントの入れ方は一般的じゃない。
        // せめて書き換えるなら、switchのままで、このように変えるんじゃねぇのかと？
        //switch (cmd) {
        //case 0:
        //    // 処理A
        //    // 処理B
        //    break;
        //case 1: // fall through
        //case 2:
        //    // 処理B
        //    break;
        //default:
        //    // 処理C
        //    break;
        //}
        // どちらにせよ自分が知らないからとかそういう理由で書き換える発想をするのは、あまり良くない。

        // ところで Java7からはswitchで文字列を扱うことが出来るようになりました。
        // そのため switchで扱えるのはint, short, char, byte, enum, Stringになります。
        // また、Stringの場合内部的にequalsと同じ処理が行われているので 大文字/小文字が区別されます。
        String color = "青色";
        switch (color) {
        case "赤色":
            System.out.println(color + ":" + "トマトの色");
            break;
        case "青色":
            System.out.println(color + ":" + "空の色"); // 青色:空の色
            break;
        default:
            break;
        }
        // ちなみに
    }
}
