/**
 * Javaの勉強 3日目(クラス)
 * 
 * @version 1.0.0
 * @author Bunya
 */

package test1;

/**
 * アプリ クラス
 * 
 */
public final class App {
    /*
     * 今回は、クラスを真面目に書きます。
     * まずクラスは多分何か分かってると思ってますが、簡単に言えば
     * クラス特有のデータの保持とそのインスタンスに対する操作を定義した雛形のことです。
     *
     * [書式]
     * @アノテーション
     * アクセス修飾子 非アクセス修飾子 class クラス名 extends 継承元クラス名 implements 実装元インターフェース名
     *
     * (@アノテーション)
     * Java 1.5(5?)から登場した機能。
     * クラスの場合で使いそうなのは @Deprecated、@Inheritedでしょうか？Deprecatedは、クラスの使用が非推奨という意味です。
     * @Inheritedは少し複雑な動きなので自分で調べてみてください。
     * Deprecatedのクラスを使用すると、コンパイルしたときに警告が出ます。
     * アノテーションにはJava標準のアノテーションとフレームワークなどが提供する独自のアノテーションがありますが、筆者が書くのはJava標準のアノテーションです。
     *
     * (アクセス修飾子)
     * 未指定:所属するパッケージからのアクセスのみを許可。
     * public:パッケージ外を含め全ての場所からアクセスを許可。つまり別パッケージからも使用可能。
     *        なお、publicの場合は必ずファイル名と同じクラス名にしなければならない。
     *        違う名前の場合、コンパイルエラーになる。
     *
     * ここで小話。
     * このアクセス修飾子で変な習慣や誤解が生まれたような気がする。
     * アクセス修飾子が未指定の場合、1ファイルの中にクラスを何個も作成できます。
     * 1ファイルに"必ず"publicのクラスが1つなければいけないわけではなく、未指定だけのクラスしかなくてもコンパイル出来ます。
     * 逆にpublicの場合は必ずファイル名と同じクラス名でなければいけないので1ファイルに1つしか用意できません。
     * 1つより多く用意するとコンパイルエラーになります。
     * publicのクラスが1つだけなのは、確かJVMがロードを簡単にするためとかいう手抜き？理由だった記憶があります。
     * 決して、なにか明確な利点があるから採用とかいう理由では、ないです。
     *
     * 個人的見解ですが、よく聞く"1ファイル1クラス"というのは、publicのクラスはファイルに1つしか作成できないというJava文法の制約を誤解したのが始まりだと考えています。
     * "1ファイル1クラスがわかりやすい"という方もいますが、実用的な開発してたら、そうならないんじゃないか？と思っています。
     * なぜかというと、このpublicの制約ってのはclass、interface、enum、独自アノテーション、record全てに適用されるわけです。
     * 例えばenumを1つだけ定義するファイルを用意するとは思えません(え、まさかJavaの人たちって、enumを全てpublicにして1つずつ用意するの？)。
     * まぁ、もし用意するんだとしたらファイル名の管理とかどうしてるんでしょうか？
     * 私の知ってる大規模開発とかだと、ファイルを新規に作るのって申請とか必要な現場が結構あるはずですが？
     * というより、そんなことすると相当長いファイル名じゃないと余計分かりづらくなるように思えるが。。。
     * 
     * その他、Javaには内部クラスや匿名クラスがあり、特に匿名クラスはラムダに発展するため、実質的にこれらも全てクラスだと私は思います。
     * 皆さんラムダを使うのどうするんでしょうかね？1ファイル1クラスなんでしょ？まさか、グローバル変数と同じで"class"がついてないのでクラス
     * ではない。とかいう迷言ｗがあるんでしょうか。
     * ※ 筆者は中間コードを逆コンパイルして確かめたわけじゃないですが、恐らくラムダは匿名クラスの限定バージョンとして定義されているのでは？と思っています。
     *
     * ちなみにC++やC#にはこの制約がありません。
     * Javaの文法を考えるに、同じパッケージの中と外というのがかなり区別されているので、publicはパッケージ外に公開する特別なものという考えがあると思ってます。
     * だから、そもそもpublicって簡単に付与するものじゃなかったと思ってるのですが、入門書でmainを用意するために必ずclassにpublicをつける必然性のせでしょうかねぇ。
     * きちんと理解しないまま、classにはpublicをつけるんだ。と誤解した例はかなりあると思ってます。
     *
     * 筆者がJavaを嫌う理由の1つでもあるのですが、Javaで育った？方は、このJavaの文法による制約・制限や
     * コーディングスタイルetcを合理的な理由なしに、他言語に適用しようとする人が多いと感じます。
     * 多分今までの考え方を変えたくないって理由でしょうが、そんなもの害悪にしかなりません。
     * だって、言語によって文法は違うし成り立ちそのものが違うのですから、当てはめていいわけがないでしょう。
     * もちろん合理的理由であれば良いと思うのですが、1ファイル1クラスに拘ると逆に分かりにくくなることはあると思うんですよね。
     * 
     * ついでに、これまた良く聞く"eclipseでは1ファイルに1クラスしか作れない"みたいな噂の類も同じ誤解から起きてるんだと思います。
     * ※ まさかeclipseがJavaの文法以上の制約を勝手に課してるとは思えないし、確か以前試したときは普通に複数class作れた記憶がある。
     *
     * Javaでまともに開発したことない筆者が語るのもなんですが、今はあまりpublicをつけたクラスはいらないんじゃないかと思ってます。
     * パッケージの外に公開するのはクラスでなく後で説明するinterface、record、enumを基本にすべきじゃないでしょうか？
     * そんなこと守ってる人は少なそうですが。
     * ただpublicでfinalもついてないクラスをポコポコ作成するのはやめた方が良いです。
     * 大規模開発なんかでは、コーディング規約にない限り、public＆finalなしなら勝手に使っていい＆勝手に継承していいいと受け取る人が多いでしょう。
     * Javaの文法がそれを許してるわけですから。
     * 大規模な開発では、阿吽の呼吸とか雰囲気で分かるでしょ的なノリではまともに開発が進みません。
     * ※ 冗談ぬきで、すごい開発の仕方/解釈をする人がいらっしゃるので。
     * 小話終了～。
     *
     * (非アクセス修飾子)
     * abstract: 抽象クラス。newでインスタンスの作成ができない。継承して使うことを強制する。
     * final: クラスの継承を禁止する。
     * strictfp: クラスの中の全てのメソッドと内部クラスで浮動小数点の精度が一定であることを保証する。
     *
     * 現代のオブジェクト指向では、クラスの継承はほとんど使われないので、基本finalをつけるのがいいと思います。
     * finalがついてない＆publicなクラスは誰が勝手に継承するかわからないので非常に危険です。
     *
     * また、現代というかstrictfpは、とうの昔に意味を失っています。
     * 元々strictfpは、x86系かつSSE2というCPUの拡張命令がない時にIEEE754に厳格に従って演算を行うかどうかでしたが、
     * 今の時代にSSE2を実装していないCPUなどまずお目にかかれないでしょう。
     *
     * (extends)
     * 継承する場合に指定します。ただ、上でも書いたように今はclassを継承してっていうのはあまり使われません。
     * デザインパターンなどでは行うこともありますが、それらも言語仕様やライブラリに組み込まれてしまってるものもあるし、
     * デザインパターンはライブラリであったりフレームワークなどを作成する場合に力を発揮するものです。
     * 単独で使用するようなものではありません。
     * ※ 単独で使って、それこそグローバル変数になってる場合が多い、シングルトンというパターンがあります。
     *    ただ、正しく使われることが少ないんですよね。そもそも、1つだけしか存在しないインスタンスってそう多くないわけですし。
     *
     * (implements)
     * interfaceを実装する場合に指定します。Javaではこのinterfaceを中心に使用して行きます。
     * ポリモーフィズムとかいうやつもこのinterfaceで行うことがほとんどでしょう。
     * 継承とかinterfaceも後で書きます。★★★
     */

    /**
     * Mainメソッド
     * 
     * @param args 起動時に与えられたコマンドの配列
     */ 
    public static void main(String[] args) {
        /*
        * ここで、のばしのばしにしてたメソッドを真面目に解説
        *
        * [書式]
        * @アノテーション
        * アクセス修飾子 static メソッド修飾子 戻り値型 メソッド名(final 引数1型 引数1名前, ・・・)
        *
        * (@アノテーション)
        * メソッドで使う筆頭は @Overrideでしょうか。Overrideは、クラスを継承してメソッドをオーバーライド
        * する時に使います。型が違う、名前が違うなどでメソッドを正しくオーバーライドできない場合にコンパイルエラーとなります。
        *
        * (アクセス修飾子)
        * 未指定: このクラス内と同じパッケージ内から呼び出し出来る。
        * private: このクラス内でのみ呼び出し出来る。
        * protected: このクラス内と継承先クラス(=Javaではサブクラス)、そして同じパッケージ内から呼び出し出来る。
        * public: 制限なしで呼び出し可能。他クラスからも呼び出せる。
        * 
        * 書いてるまんまですが、メジャーな言語ではJava唯一？で未指定の場合がprivateと同じになりません。
        * また、protectedもJavaだけ同じパッケージ内から呼び出し可能です。
        * なぜかここだけ突然C言語のように現場での利便性重視に思えるのですが、まぁJavaという言語の思想では、
        * それくらい同じパッケージというのは特別扱いされると思えばいいのではないでしょうか。
        * ※ 実のところ同じパッケージ内は同一人物や同一企業で開発するでしょうから、そんなに間違えてるわけでもないかなと。
        *    学者が考えたとしか思えない頑固、偏屈さを持つJavaは、個人的に最後まで利便性に流れてほしくないところですがｗ
        *
        * (static) ※本当はメソッド修飾子の一部だけどstatic finalって順番で書かれることも多いし説明のしやすさで別項目にした。
        * ここまでずっと無視してきたstaticです。
        * 意味はnewによりインスタンス化なしで呼び出せるメソッドを意味します。
        * 基本的に余程の熟練者にでもならない限り、mainメソッド以外につけるべきではありません。
        * 使う場合は既に吟味されてstaticになっていると思うので、気にしなくていいと思います。
        * また、staticメソッドはインスタンス化することなく呼び出せる関係上、
        * staicメソッドから呼び出せるメソッドは全てstaticである必要があります。
        * 
        * また、後で説明するフィールドについてもstaticがついてないものはアクセスできません。
        * そして、thisもstaticメソッド内では使えません。
        *
        * (メソッド修飾子)
        * abstract: 抽象メソッド。処理を記述できない。継承先のサブクラス内でオーバーライドしなければならない。
        * final: メソッドのオーバーライドを禁止する。
        *
        * Javaは時代背景もあるけど、全メソッドがデフォルトでオーバーライド可能です。
        * 他の言語のようにオーバーライド対象メソッドにvirtualをつけるとかではなく、デフォルトでオーバーライド可能です。
        * ですが、このデフォルトでオーバーライド可能は既に駄目な文法として過去のものになっています。
        * なぜなら作成者がオーバーライドしても良いと思ってもいなかったメソッドが、勝手にオーバーライドされてしまうからです。
        * そんな思ってもいなかったメソッドがオーバーライドされることで親クラス(=スーパークラス)の変更が縛られてしまいます。
        * そのため、もしクラスをfinalとして継承不能にしない場合、全メソッドにfinalを付与しないのは危険です。
        * 今はinterfaceの実装を中心においていると思うので、コーディング規則にない限りクラスをfinalにしてメソッドにはfinalをつけない
        * のが楽じゃないかなと。
        * ※ ちなみに継承の退化？減少？に伴って、protectedを用意するのもかなり時代遅れのやり方になっています。
        *
        * strictfp: このメソッドで浮動小数の精度が一定であることを保証。既に意味なし。
        * synchronized: 同時に複数のスレッドが呼び出せないようにします。マルチスレッドで重要。★★★
        * native: Java以外の言語で書かれたコードを使用することを宣言。実はSystem.out.println()なんかもそうです。
        *
        * (戻り値型)
        * これ以降はさすがに知ってるでしょうから、(ry
        * おっとでもfinalのやつは参照型引数のクラス版の振る舞いに関係するので後で書きます。★★★
        *
        * 可変長引数ってのもJDK1.5(Java 5？)から使えるようになりましたが、普通の用途で必要になることはないでしょう。
        */

        // メソッドの呼び出し
        first();
        second();

        // 画面に表示する
        System.out.println("正常終了");
    }

    /**
     * 最初のメソッド(説明用)
     * 
     */ 
    static void first() {
        var subA = new SubA();
        System.out.println(subA.twice(2));
    }

    /**
     * 2つ目のメソッド(説明用)
     * 
     */ 
    static void second() {
        var sub1 = new SubB();
        var sub2 = new SubB();
    }

}
