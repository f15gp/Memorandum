/**
 * Javaの勉強 3日目(クラス)
 * 
 * @version 1.0.0
 * @author Bunya
 */

package test1;

/**
 * アプリ クラス
 * 
 */
public final class App {
    /*
     * 今回は、クラスを真面目に書きます。
     * まずクラスは多分何か分かってると思ってますが、簡単に言えば
     * クラス特有のデータの保持とそのインスタンスに対する操作を定義した雛形のことです。
     *
     * [書式]
     * @アノテーション
     * アクセス修飾子 非アクセス修飾子 class クラス名 extends 継承元クラス名 implements 実装元インターフェース名
     *
     * (@アノテーション)
     * Java 1.5(5?)から登場した機能。
     * クラスの場合で使いそうなのは @Deprecated、@Inheritedでしょうか？Deprecatedは、クラスの使用が非推奨という意味です。
     * @Inheritedは少し複雑な動きなので自分で調べてみてください。
     * Deprecatedのクラスを使用すると、コンパイルしたときに警告が出ます。
     * アノテーションにはJava標準のアノテーションとフレームワークなどが提供する独自のアノテーションがありますが、筆者が書くのはJava標準のアノテーションです。
     *
     * (アクセス修飾子)
     * 未指定:所属するパッケージからのアクセスのみを許可。
     * public:パッケージ外を含め全ての場所からアクセスを許可。つまり別パッケージからも使用可能。
     *        なお、publicの場合は必ずファイル名と同じクラス名にしなければならない。
     *        違う名前の場合、コンパイルエラーになる。
     *
     * ここで小話。(興味ない方は、"非アクセス修飾子"までスキップよろ)
     * このアクセス修飾子で変な習慣や誤解が生まれたような気がします。
     * アクセス修飾子が未指定の場合、1ファイルの中にクラスを何個も作成できます。
     * また、1ファイルに"必ず"publicのクラスが1つなければいけないわけではなく、未指定だけのクラスしかなくてもコンパイル出来ます。
     * 逆にpublicの場合は必ずファイル名と同じクラス名でなければいけないので1ファイルに1つしか用意できません。
     * 1つより多く用意するとコンパイルエラーになります。
     * publicのクラスが1つだけなのは、確かJVMがロードを簡単にするためとかいう手抜き？理由だった記憶があります。
     * 決して、なにか明確な利点があるから採用とかいう理由では、ないです。
     *
     * 個人的見解ですが、よく聞く"1ファイル1クラス"というのは、publicのクラスはファイルに1つしか作成できないというJava文法の制約を誤解したのが始まりだと考えています。
     * そこから後付けで、"1ファイル1クラスがわかりやすい。保守しやすい"が生まれたのかなと。
     * "1ファイル1クラスがわかりやすい"という考えかたの方に申し訳ないですが、実際の開発ではそうならないんじゃないか？と思っています。
     * なぜかというと、このpublicの制約ってのはclass、interface、enum、独自アノテーション、record全てに適用されるわけです。
     * ※ Javaで開発したことない人間が語るのは全く説得力がないですが、いやしかし・・・
     *
     * 例えばenumを1つだけ定義するファイルを用意するとは思えません(え、まさかJavaの人たちって、enumを全てpublicにして1つずつ用意するの？)。
     * まぁ、もし用意するんだとしたらファイル名の管理とかどうしてるんでしょうか？
     * 私の知ってる大規模開発とかだと、ファイルを新規に作るのって申請とか必要な現場が結構あるはずですが？(今はもうないのか？)
     * というより、そんなことすると相当長いファイル名じゃないと余計分かりづらくなるように思えるが。。。
     * 
     * その他、Javaには内部クラスや匿名クラスがあり、特に匿名クラスはラムダに発展するため、実質的にこれらも全てクラスだと筆者は思ってます。
     * 皆さん、ラムダを使う場合とかどうするんでしょうかね？1ファイル1クラスなんでしょ？
     * まさか、グローバル変数と同じで、""class"がついてないのでクラスではない。ｷﾘ"とかいう迷言？があるんでしょうか。
     * ※ 筆者は中間コードを逆コンパイルして確かめたわけじゃないですが、恐らくラムダは匿名クラスの限定バージョンとして定義されているのでは？と思っています。
     *
     * ちなみにC++やC#にこのような制約、コーディング規約はありません。
     * Javaの文法を考えるに、同じパッケージの中と外というのがかなり区別されているので、publicはパッケージ外に公開する特別なものという考えがあると思ってます。
     * だから、元々Javaではクラスのpublicって簡単に付与するものじゃなかったのではないでしょうか。
     * ただ、入門書でmainを用意するために必ずclassにpublicをつけたものを延々と使いまわされてしまうせいで、
     * きちんと理解しないまま、classにはpublicをつけるんだ。と誤解した例はかなりあると思ってます。
     * ※ というか、筆者はそれがあるのでC#やJavaを入門に使うのは嫌だったんです。
     *    でも、JavaはJDK 21からmainのメソッドだけ(つまり外側のクラスがいらないし、staticも不要)書いて実行できるようになってます。
     *    C#は10.0からもっと踏み込んで、そもそもメソッドすら無しでいきなり処理が書けるようになってます。
     *    つまり、規格を決定する方たちもいきなりclassやstaticの説明してないのにmainのために必要というのは問題だと考えていたってことですね。安心しました。     
     *
     * 筆者がJavaを嫌う理由の1つでもあるのですが、Javaで育った？(どんな言語でもそうかもしれない)方は、このJavaの文法による制約・制限や
     * コーディングスタイルetcを合理的な理由なしに、他言語での開発にも適用しようとする人が比較的多いと感じてます。
     * 多分今までの考え方を変えたくないって理由でしょうが、そんなもの害悪にしかなりません。
     * だって、言語によって文法は違うし成り立ちそのものが違うのですから、当てはめていいわけがないでしょう。
     * もちろん合理的理由であれば良いと思うのですが、1ファイル1クラスに拘ると逆に分かりにくくなることはあると思うんですよね。
     * 関連している列挙型が別ファイルになってるとしたら、それをまとめるためだけのパッケージを作らないと混乱しそう。。。
     * ※ 筆者がC++で開発する時など、関連する構造体を1ファイルにまとめたり、クラスの中で関連する列挙型を用意して公開するなどということを頻繁に行うので、
     *    とてもじゃないですが、1ファイル1クラスで開発しろと強制されたら効率が落ちること請け合いです。
     *    てかJavaだから全てパッケージで分けろと言われれば分からなくもないですが、(ファイル名を考えるなど)面倒なのは間違いない。
     * 
     * ついでに、これまた良く聞く"eclipseでは1ファイルに1クラスしか作れない"みたいな噂の類も同じ誤解から起きてるんだと思います。
     * ※ まさかeclipseがJavaの文法以上の制約を勝手に課してるとは思えないし、確か以前試したときは普通に複数class作れた記憶がある。
     *
     * Javaでまともに開発したことない筆者が語るのもなんですが、今はあまりpublicをつけたクラスはいらないんじゃないかと思ってます。
     * パッケージの外に公開するのはクラスでなく後で説明するinterface、record、enumを基本にすべきじゃないでしょうか？
     * ただ、これだけは言えるのが、publicでfinalもついてないクラスをポコポコ作成するのはやめた方が良いです。
     * 大規模開発なんかでは、コーディング規約にない限り、public＆finalなしなら勝手に使っていい＆勝手に継承していいいと受け取る人が多いでしょう。
     * Javaの文法がそれを許してるわけですから。
     * 大規模な開発では、阿吽の呼吸とか雰囲気で分かるでしょ的なノリではまともに開発が進みません。
     * ※ 冗談ぬきで、すごい開発の仕方/解釈をする人がいらっしゃるので。
     * 小話終了～。
     *
     * (非アクセス修飾子)
     * abstract: 抽象クラス。newでインスタンスの作成ができない。継承して使うことを強制する。
     * final: クラスの継承を禁止する。
     * strictfp: クラスの中の全てのメソッドと内部クラスで浮動小数点の精度が一定であることを保証する。
     *
     * 現代のオブジェクト指向では、クラスの継承はほとんど使われないので、基本finalをつけるのがいいと思います。
     * finalがついてない＆publicなクラスは誰が勝手に継承するかわからないので非常に危険です。
     *
     * また、現代というかstrictfpは、とうの昔に意味を失っています。
     * 元々strictfpは、x86系かつSSE2というCPUの拡張命令がない時にIEEE754に厳格に従って演算を行うかどうかでしたが、
     * 今の時代にSSE2を実装していないCPUなどまずお目にかかれないでしょう。
     *
     * (extends)
     * 継承する場合に指定します。ただ、上でも書いたように今はclassを継承してっていうのはあまり使われません。
     * デザインパターンなどでは行うこともありますが、それらも言語仕様やライブラリに組み込まれてしまってるものもあるし、
     * デザインパターンはライブラリであったりフレームワークなどを作成する場合に力を発揮するものです。
     * 単独で使用するようなものではありません。
     * ※ 単独で使って、それこそグローバル変数になってる場合が多い、シングルトンというパターンがあります。
     *    ただ、正しく使われることが少ないんですよね。そもそも、1つだけしか存在しないインスタンスってそう多くないわけですし。
     *
     * (implements)
     * interfaceを実装する場合に指定します。Javaではこのinterfaceを中心に使用して行きます。
     * ポリモーフィズムとかいうやつもこのinterfaceで行うことがほとんどでしょう。
     * 継承とかinterfaceも後で書きます。★★★
     */

    /**
     * Mainメソッド
     * 
     * @param args 起動時に与えられたコマンドの配列
     */ 
    public static void main(String[] args) {
        /*
        * ここで、のばしのばしにしてたメソッドを真面目に解説
        *
        * [書式]
        * @アノテーション
        * アクセス修飾子 static メソッド修飾子 戻り値型 メソッド名(final 引数1型 引数1名前, ・・・)
        *
        * (@アノテーション)
        * メソッドで使う筆頭は @Overrideでしょうか。Overrideは、クラスを継承してメソッドをオーバーライド
        * する時に使います。型が違う、名前が違うなどでメソッドを正しくオーバーライドできない場合にコンパイルエラーとなります。
        *
        * (アクセス修飾子)
        * 未指定: このクラス内と同じパッケージ内から呼び出し出来る。
        * private: このクラス内でのみ呼び出し出来る。
        * protected: このクラス内と継承先クラス(=Javaではサブクラス)、そして同じパッケージ内から呼び出し出来る。
        * public: 制限なしで呼び出し可能。他クラスからも呼び出せる。
        * 
        * 書いてるまんまですが、未指定の場合はprivateと同じになりません。お気を付け下さい。
        * また、protectedは同じパッケージ内から呼び出しが可能に注意。
        * なぜかここだけ突然C言語のように現場での利便性重視に思えるのですが、まぁJavaという言語の思想では、
        * それくらい同じパッケージというのは特別扱いされると思えばいいのではないでしょうか。
        * ※ 実のところ同じパッケージ内は同一人物や同一企業で開発するでしょうから、そんなに間違えてるわけでもないかなと。
        *    学者が考えたとしか思えない頑固、偏屈さを持つJavaは、個人的に最後まで利便性に流れてほしくないところですがｗ
        *
        * (static) ※本当はメソッド修飾子の一部だけどstatic finalって順番で書かれることも多いし説明のしやすさで別項目にした。
        * ここまでずっと無視してきたstaticです。
        * 意味はnewによりインスタンス化なしで呼び出せるメソッドを意味します。
        * 基本的に余程の熟練者にでもならない限り、mainメソッド以外につけるべきではありません。
        * 使う場合は既に吟味されてstaticになっていると思うので、気にしなくていいと思います。
        * また、staticメソッドはインスタンス化することなく呼び出せる関係上、
        * staicメソッドから呼び出せるメソッドは全てstaticである必要があります。
        * 
        * 後で説明するフィールドについてもstaticがついてないものはアクセスできません。
        * そして、thisもstaticメソッド内では使えません。
        * ただ、Javaで一般的かどうかは謎ですが、private staticなメソッドであれば気楽に作っていいかなと思います。
        * それの目的ってなんですか？というと、各メソッドの下請け処理や共通処理を実装することです。
        * なんでstaticで？というと、staticだと引数、戻り値でデータを受け渡ししなくてはならず、フィールドにアクセスしないからです。
        * 良く、privateメソッドだからと好き勝手にフィールドを使うプログラムを見ますが、
        * 筆者はそのような使い方をクラス内グローバル変数と呼んでます。それを防げるので意味があるかなと思ってます。
        *
        * (メソッド修飾子)
        * abstract: 抽象メソッド。処理を記述できない。継承先のサブクラス内でオーバーライドしなければならない。
        * final: メソッドのオーバーライドを禁止する。
        *
        * Javaは時代背景もあるけど、全メソッドがデフォルトでオーバーライド可能です。
        * 他の言語のようにオーバーライド対象メソッドにvirtualをつけるとかではなく、デフォルトでオーバーライド可能です。
        * ですが、このデフォルトでオーバーライド可能は既に駄目な文法として過去のものになっています。
        * なぜなら作成者がオーバーライドしても良いと思ってもいなかったメソッドが、勝手にオーバーライドされてしまうからです。
        * そんな思ってもいなかったメソッドがオーバーライドされることで親クラス(=スーパークラス)の変更が縛られてしまいます。
        * そのため、もしクラスをfinalとして継承不能にしない場合、全メソッドにfinalを付与しないのは危険です。
        * 今はinterfaceの実装を中心においていると思うので、コーディング規則にない限りクラスをfinalにしてメソッドにはfinalをつけない
        * のが楽じゃないかなと。
        * ※ ちなみに継承の退化？減少？に伴って、protectedを用意するのもかなり時代遅れのやり方になっています。
        *
        * strictfp: このメソッドで浮動小数の精度が一定であることを保証。既に意味なし。
        * synchronized: 同時に複数のスレッドが呼び出せないようにします。マルチスレッドで重要。★★★
        * native: Java以外の言語で書かれたコードを使用することを宣言。実はSystem.out.println()なんかもそうです。
        *
        * (戻り値型)
        * これ以降はさすがに知ってるでしょうから、(ry
        * おっとでもfinalのやつは参照型引数のクラス版の振る舞いに関係するので後で書きます。★★★
        *
        * 可変長引数ってのもJDK1.5(Java 5？)から使えるようになりましたが、あまり必要になることはないでしょう。
        * 自分でコレクションライブラリを実装するとかなら使うかもしれませんが、はたして。
        */

        // メソッドの呼び出し
        first();
        second();

        // 画面に表示する
        System.out.println("正常終了");
    }

    /**
     * 最初のメソッド(説明用)
     * 
     */ 
    static void first() {
        var subA = new SubA();
        System.out.println(subA.twice(2));
    }

    /**
     * 2つ目のメソッド(説明用)
     * 
     */ 
    static void second() {
        var sub1 = new SubB();
        var sub2 = new SubB();
    }

}
